<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Neon Bomberman</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    image-rendering: pixelated;
}

body {
    font-family: 'Press Start 2P', cursive;
    background: #0a0a15;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    overflow: hidden;
}

#gameContainer {
    position: relative;
    z-index: 1;
}

#hud {
    display: flex;
    justify-content: space-between;
    margin-bottom: 15px;
    padding: 15px 25px;
    background: #000;
    border: 4px solid #00ff00;
    box-shadow: 0 0 20px rgba(0,255,0,0.5);
}

.stat {
    color: #00ff00;
    font-size: 12px;
    text-shadow: 0 0 8px #00ff00;
    text-align: center;
}

.stat-value {
    font-size: 20px;
    color: #fff;
    margin-top: 5px;
}

#timer {
    color: #ffff00;
    font-size: 40px;
    text-shadow: 0 0 15px #ffff00;
}

#timer.warning {
    color: #ff8800;
}

#timer.danger {
    color: #ff0000;
    animation: pulse 0.2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

#gameBoard {
    display: grid;
    gap: 2px;
    padding: 15px;
    background: #000;
    border: 5px solid #ff00ff;
    box-shadow: 0 0 30px rgba(255,0,255,0.6);
}

.tile {
    width: 60px;
    height: 60px;
    background: #1a1a2e;
    border: 3px solid #0f3460;
    position: relative;
    box-shadow: 
        inset 2px 2px 0 rgba(255,255,255,0.1),
        inset -2px -2px 0 rgba(0,0,0,0.5);
}

.tile.destroyed {
    background: #2a0000;
    border-color: #600000;
    box-shadow: 
        inset 2px 2px 0 rgba(255,0,0,0.2),
        inset -2px -2px 0 rgba(0,0,0,0.8),
        0 0 10px rgba(255,0,0,0.5);
}

.tile.destroyed::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 80%;
    height: 80%;
    transform: translate(-50%, -50%);
    background: 
        linear-gradient(45deg, transparent 45%, #600000 45%, #600000 55%, transparent 55%),
        linear-gradient(-45deg, transparent 45%, #600000 45%, #600000 55%, transparent 55%);
}

.player {
    position: absolute;
    width: 32px;
    height: 24px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10;
}

/* Space Invaders style alien */
.player::before {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    background: 
        /* Antennae */
        linear-gradient(to right, transparent 25%, #00ff00 25%, #00ff00 31.25%, transparent 31.25%, transparent 68.75%, #00ff00 68.75%, #00ff00 75%, transparent 75%),
        /* Top of head */
        linear-gradient(to right, transparent 18.75%, #00ff00 18.75%, #00ff00 81.25%, transparent 81.25%),
        /* Eyes row */
        linear-gradient(to right, transparent 18.75%, #00ff00 18.75%, #00ff00 31.25%, #000 31.25%, #000 37.5%, #00ff00 37.5%, #00ff00 62.5%, #000 62.5%, #000 68.75%, #00ff00 68.75%, #00ff00 81.25%, transparent 81.25%),
        /* Body top with notch */
        linear-gradient(to right, transparent 12.5%, #00ff00 12.5%, #00ff00 43.75%, transparent 43.75%, transparent 56.25%, #00ff00 56.25%, #00ff00 87.5%, transparent 87.5%),
        /* Body middle */
        linear-gradient(to right, transparent 12.5%, #00ff00 12.5%, #00ff00 87.5%, transparent 87.5%),
        /* Arms row */
        linear-gradient(to right, #00ff00 0%, #00ff00 12.5%, transparent 12.5%, transparent 18.75%, #00ff00 18.75%, #00ff00 31.25%, transparent 31.25%, transparent 68.75%, #00ff00 68.75%, #00ff00 81.25%, transparent 81.25%, transparent 87.5%, #00ff00 87.5%, #00ff00 100%),
        /* Legs */
        linear-gradient(to right, transparent 18.75%, #00ff00 18.75%, #00ff00 31.25%, transparent 31.25%, transparent 68.75%, #00ff00 68.75%, #00ff00 81.25%, transparent 81.25%),
        /* Feet */
        linear-gradient(to right, transparent 12.5%, #00ff00 12.5%, #00ff00 18.75%, transparent 18.75%, transparent 31.25%, #00ff00 31.25%, #00ff00 37.5%, transparent 37.5%, transparent 62.5%, #00ff00 62.5%, #00ff00 68.75%, transparent 68.75%, transparent 81.25%, #00ff00 81.25%, #00ff00 87.5%, transparent 87.5%);
    background-size: 
        100% 12.5%,
        100% 12.5%,
        100% 12.5%,
        100% 12.5%,
        100% 12.5%,
        100% 12.5%,
        100% 12.5%,
        100% 12.5%;
    background-position: 
        0 0%,
        0 12.5%,
        0 25%,
        0 37.5%,
        0 50%,
        0 62.5%,
        0 75%,
        0 87.5%;
    background-repeat: no-repeat;
    filter: drop-shadow(0 0 6px #00ff00);
    animation: bob 0.4s ease-in-out infinite;
}

@keyframes bob {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-2px); }
}

.bomb {
    position: absolute;
    width: 32px;
    height: 32px;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    image-rendering: pixelated;
    image-rendering: -moz-crisp-edges;
    image-rendering: crisp-edges;
    filter: drop-shadow(0 0 8px var(--bomb-glow)) drop-shadow(0 0 16px var(--bomb-glow));
    animation: bombPulse 0.35s ease-in-out infinite;
}

@keyframes bombPulse {
    0%, 100% { 
        transform: translate(-50%, -50%) scale(1);
    }
    50% { 
        transform: translate(-50%, -50%) scale(1.1);
    }
}

.bomb.blue { --bomb-glow: #0066ff; }
.bomb.red { --bomb-glow: #ff0000; }
.bomb.green { --bomb-glow: #00ff00; }
.bomb.magenta { --bomb-glow: #ff55ff; }
.bomb.yellow { --bomb-glow: #ffff00; }
.bomb.cyan { --bomb-glow: #00ffff; }
.bomb.white { --bomb-glow: #ffffff; }
.bomb.void { --bomb-glow: #666666; }
.bomb.orange { --bomb-glow: #ff8800; }
.bomb.lightning { --bomb-glow: #cccccc; }

.bomb.blue { --bomb-color: #0066ff; }
.bomb.red { --bomb-color: #ff0000; }
.bomb.green { --bomb-color: #00ff00; }
.bomb.magenta { --bomb-color: #ff55ff; }
.bomb.yellow { --bomb-color: #ffff00; }
.bomb.cyan { --bomb-color: #00ffff; }
.bomb.white { --bomb-color: #ffffff; }
.bomb.void { --bomb-color: #000000; }
.bomb.orange { --bomb-color: #ff8800; }
.bomb.lightning { --bomb-color: #cccccc; }

.explosion {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 100;
}

.particle {
    position: absolute;
    width: 6px;
    height: 6px;
    background: var(--particle-color);
    box-shadow: 0 0 8px var(--particle-color);
    pointer-events: none;
    animation: explode 1.0s ease-out forwards;
}

@keyframes explode {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    70% {
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}

.flash {
    position: absolute;
    background: #fff;
    opacity: 0.9;
    z-index: 50;
    animation: flash 0.5s ease-out forwards;
}

@keyframes flash {
    0% { opacity: 0.9; }
    50% { opacity: 0.6; }
    100% { opacity: 0; }
}

#gameOver {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000;
    padding: 40px;
    border: 6px solid #ff0000;
    text-align: center;
    z-index: 1000;
    box-shadow: 0 0 60px rgba(255,0,0,0.8);
}

#gameOver h1 {
    color: #ff0000;
    font-size: 40px;
    margin-bottom: 20px;
    text-shadow: 0 0 20px #ff0000;
}

#gameOver p {
    color: #fff;
    font-size: 14px;
    margin: 10px 0;
}

#gameOver button {
    margin-top: 25px;
    padding: 12px 30px;
    font-family: 'Press Start 2P', cursive;
    font-size: 14px;
    background: #00ff00;
    border: 4px solid #00ff00;
    color: #000;
    cursor: pointer;
    box-shadow: 0 0 20px rgba(0,255,0,0.5);
}

#gameOver button:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(0,255,0,0.8);
}
</style>
</head>
<body>

<div id="gameContainer">
    <div id="hud">
        <div class="stat">
            <div>SCORE</div>
            <div class="stat-value" id="score">0</div>
        </div>
        <div class="stat">
            <div id="timer">5.0</div>
        </div>
        <div class="stat">
            <div>HIGH</div>
            <div class="stat-value" id="highScore">0</div>
        </div>
        <div class="stat">
            <div>TURN</div>
            <div class="stat-value" id="turn">1</div>
        </div>
    </div>
    
    <div id="gameBoard"></div>
</div>

<div id="gameOver">
    <h1>GAME OVER</h1>
    <p>SCORE: <span id="finalScore">0</span></p>
    <p>TURNS: <span id="finalTurn">0</span></p>
    <p>HIGH: <span id="finalHigh">0</span></p>
    <button onclick="restartGame()">RETRY</button>
</div>

<div id="explosionLayer" class="explosion"></div>

<script>
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playSound(freq, duration, type = 'square', volume = 0.08) {
    try {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.frequency.value = freq;
        osc.type = type;
        gain.gain.value = volume;
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    } catch(e) {}
}

const GRID_SIZE = 9;
const INITIAL_COUNTDOWN = 5.0;
const MIN_COUNTDOWN = 1.5;
const COUNTDOWN_DECREASE = 0.05;

const BOMB_TYPES = {
    blue: { color: '#0066ff', pattern: 'cross', weight: 100, power: 1 },
    red: { color: '#ff0000', pattern: 'diagonal', weight: 100, power: 1 },
    green: { color: '#00ff00', pattern: 'area3x3', weight: 60, power: 2 },
    cyan: { color: '#00ffff', pattern: 'combo_cross_area', weight: 30, power: 3 },
    yellow: { color: '#ffff00', pattern: 'combo_diagonal_area', weight: 30, power: 3 },
    magenta: { color: '#ff55ff', pattern: 'combo_cross_diagonal', weight: 25, power: 3 },
    orange: { color: '#ff8800', pattern: 'ring5x5', weight: 20, power: 2 },
    void: { color: '#000000', pattern: 'void3x3', weight: 15, power: 4 },
    white: { color: '#ffffff', pattern: 'combo_all', weight: 5, power: 5 },
    lightning: { color: '#cccccc', pattern: 'random', weight: 12, power: 3 }
};

let gameBoard = [];
let playerPos = { row: 4, col: 4 };
let bombs = [];
let destroyedTiles = new Set();
let score = 0;
let turn = 1;
let highScore = localStorage.getItem('bomberman-high') || 0;
let countdown = INITIAL_COUNTDOWN;
let countdownInterval = null;
let isGameOver = false;
let canMove = true;
let currentCountdownMax = INITIAL_COUNTDOWN;

function init() {
    document.getElementById('highScore').textContent = highScore;
    createBoard();
    setupControls();
    startTurn();
}

function createBoard() {
    const board = document.getElementById('gameBoard');
    board.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 60px)`;
    board.innerHTML = '';
    gameBoard = [];
    
    for(let r = 0; r < GRID_SIZE; r++) {
        gameBoard[r] = [];
        for(let c = 0; c < GRID_SIZE; c++) {
            const tile = document.createElement('div');
            tile.className = 'tile';
            
            if(r === playerPos.row && c === playerPos.col) {
                const player = document.createElement('div');
                player.className = 'player';
                tile.appendChild(player);
            }
            
            board.appendChild(tile);
            gameBoard[r][c] = tile;
        }
    }
}

function setupControls() {
    document.addEventListener('keydown', (e) => {
        if(isGameOver || !canMove) return;
        
        let newRow = playerPos.row;
        let newCol = playerPos.col;
        
        switch(e.code) {
            case 'ArrowUp':
            case 'KeyW':
                newRow--;
                e.preventDefault();
                break;
            case 'ArrowDown':
            case 'KeyS':
                newRow++;
                e.preventDefault();
                break;
            case 'ArrowLeft':
            case 'KeyA':
                newCol--;
                e.preventDefault();
                break;
            case 'ArrowRight':
            case 'KeyD':
                newCol++;
                e.preventDefault();
                break;
        }
        
        if(newRow >= 0 && newRow < GRID_SIZE && newCol >= 0 && newCol < GRID_SIZE) {
            const tileKey = `${newRow},${newCol}`;
            if(!destroyedTiles.has(tileKey)) {
                movePlayer(newRow, newCol);
            } else {
                playSound(150, 0.1);
            }
        }
    });
}

function movePlayer(newRow, newCol) {
    const oldTile = gameBoard[playerPos.row][playerPos.col];
    const player = oldTile.querySelector('.player');
    if(player) oldTile.removeChild(player);
    
    playerPos = { row: newRow, col: newCol };
    const newTile = gameBoard[newRow][newCol];
    const newPlayer = document.createElement('div');
    newPlayer.className = 'player';
    newTile.appendChild(newPlayer);
    
    playSound(400, 0.05);
}

function startTurn() {
    // DON'T clear destroyed tiles yet - they last one more turn!
    // We'll clear them at the END of this turn
    
    spawnBombs();
    
    countdown = currentCountdownMax;
    canMove = true;
    updateTimer();
    
    countdownInterval = setInterval(() => {
        countdown -= 0.1;
        if(countdown < 0) countdown = 0;
        updateTimer();
        
        if(countdown <= 0) {
            clearInterval(countdownInterval);
            canMove = false;
            explodeBombs();
        }
    }, 100);
}

function updateTimer() {
    const timerEl = document.getElementById('timer');
    timerEl.textContent = countdown.toFixed(1);
    
    if(countdown <= 1.0) {
        timerEl.className = 'danger';
        if(countdown % 0.5 < 0.1) playSound(900, 0.05);
    } else if(countdown <= 2.0) {
        timerEl.className = 'warning';
        if(countdown % 0.5 < 0.1) playSound(600, 0.05);
    } else {
        timerEl.className = '';
        if(countdown % 1.0 < 0.1 && countdown < currentCountdownMax) playSound(400, 0.05);
    }
}

function createBombSprite(color) {
    const canvas = document.createElement('canvas');
    canvas.width = 16;
    canvas.height = 16;
    const ctx = canvas.getContext('2d');
    
    // Pixel art bomb pattern
    const pattern = [
        '      .....     ',
        '     .......    ',
        '    .........   ',
        '   ...........  ',
        '  ............. ',
        ' .............. ',
        ' .............. ',
        ' .............. ',
        ' .............. ',
        '  ............. ',
        '   ...........  ',
        '    .........   ',
        '     .......    ',
        '      .....     ',
        '                ',
        '                '
    ];
    
    // Parse color
    const r = parseInt(color.slice(1,3), 16);
    const g = parseInt(color.slice(3,5), 16);
    const b = parseInt(color.slice(5,7), 16);
    
    // Draw bomb
    for(let y = 0; y < 16; y++) {
        for(let x = 0; x < 16; x++) {
            if(pattern[y][x] === '.') {
                // Calculate shading
                let shade = 1.0;
                if(x < 5 && y < 8) shade = 1.2; // Highlight
                else if(x > 10 && y > 7) shade = 0.6; // Shadow
                
                ctx.fillStyle = `rgb(${Math.min(255, r*shade)}, ${Math.min(255, g*shade)}, ${Math.min(255, b*shade)})`;
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }
    
    // Draw fuse
    ctx.fillStyle = '#222';
    ctx.fillRect(11, 2, 1, 1);
    ctx.fillRect(12, 1, 1, 1);
    ctx.fillRect(13, 0, 1, 1);
    
    // Draw spark
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(13, -1, 1, 1);
    ctx.fillRect(14, 0, 1, 1);
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(14, 1, 1, 1);
    
    return canvas.toDataURL();
}

function spawnBombs() {
    bombs = [];
    
    const baseBombs = 1;
    const turnBombs = Math.floor((turn - 1) / 3);
    const bombCount = Math.min(baseBombs + turnBombs, 15);
    
    const weightedPool = [];
    Object.keys(BOMB_TYPES).forEach(type => {
        const adjustedWeight = Math.max(1, BOMB_TYPES[type].weight - turn);
        for(let i = 0; i < adjustedWeight; i++) {
            weightedPool.push(type);
        }
    });
    
    let validBombs = null;
    for(let attempt = 0; attempt < 500; attempt++) {
        const tempBombs = [];
        const used = new Set([`${playerPos.row},${playerPos.col}`]);
        
        for(let i = 0; i < bombCount; i++) {
            let placed = false;
            for(let tries = 0; tries < 30; tries++) {
                const row = Math.floor(Math.random() * GRID_SIZE);
                const col = Math.floor(Math.random() * GRID_SIZE);
                const key = `${row},${col}`;
                
                if(!used.has(key)) {
                    const type = weightedPool[Math.floor(Math.random() * weightedPool.length)];
                    tempBombs.push({ row, col, type });
                    used.add(key);
                    placed = true;
                    break;
                }
            }
        }
        
        if(hasSafeTile(tempBombs)) {
            validBombs = tempBombs;
            break;
        }
    }
    
    bombs = validBombs || [{ row: 0, col: 0, type: 'blue' }];
    
    bombs.forEach(bomb => {
        const tile = gameBoard[bomb.row][bomb.col];
        const bombEl = document.createElement('div');
        bombEl.className = `bomb ${bomb.type}`;
        
        // Create actual pixel art image
        const img = document.createElement('img');
        img.src = createBombSprite(BOMB_TYPES[bomb.type].color);
        img.style.width = '100%';
        img.style.height = '100%';
        img.style.imageRendering = 'pixelated';
        bombEl.appendChild(img);
        
        tile.appendChild(bombEl);
    });
}

function hasSafeTile(bombList) {
    const danger = new Set();
    
    bombList.forEach(bomb => {
        getAffectedTiles(bomb.row, bomb.col, BOMB_TYPES[bomb.type].pattern).forEach(k => danger.add(k));
    });
    
    for(let r = 0; r < GRID_SIZE; r++) {
        for(let c = 0; c < GRID_SIZE; c++) {
            const key = `${r},${c}`;
            if(!danger.has(key) && !destroyedTiles.has(key)) return true;
        }
    }
    return false;
}

function getAffectedTiles(row, col, pattern) {
    const affected = [];
    
    if(pattern === 'cross') {
        for(let c = 0; c < GRID_SIZE; c++) affected.push(`${row},${c}`);
        for(let r = 0; r < GRID_SIZE; r++) affected.push(`${r},${col}`);
    } else if(pattern === 'diagonal') {
        for(let i = -GRID_SIZE; i < GRID_SIZE; i++) {
            if(row+i >= 0 && row+i < GRID_SIZE && col+i >= 0 && col+i < GRID_SIZE) {
                affected.push(`${row+i},${col+i}`);
            }
            if(row+i >= 0 && row+i < GRID_SIZE && col-i >= 0 && col-i < GRID_SIZE) {
                affected.push(`${row+i},${col-i}`);
            }
        }
    } else if(pattern === 'area3x3') {
        for(let dr = -1; dr <= 1; dr++) {
            for(let dc = -1; dc <= 1; dc++) {
                const nr = row + dr, nc = col + dc;
                if(nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                    affected.push(`${nr},${nc}`);
                }
            }
        }
    } else if(pattern === 'combo_cross_diagonal') {
        affected.push(...getAffectedTiles(row, col, 'cross'));
        affected.push(...getAffectedTiles(row, col, 'diagonal'));
    } else if(pattern === 'combo_diagonal_area') {
        affected.push(...getAffectedTiles(row, col, 'diagonal'));
        affected.push(...getAffectedTiles(row, col, 'area3x3'));
    } else if(pattern === 'combo_cross_area') {
        affected.push(...getAffectedTiles(row, col, 'cross'));
        affected.push(...getAffectedTiles(row, col, 'area3x3'));
    } else if(pattern === 'combo_all') {
        for(let dr = -2; dr <= 2; dr++) {
            for(let dc = -2; dc <= 2; dc++) {
                const nr = row + dr, nc = col + dc;
                if(nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                    affected.push(`${nr},${nc}`);
                }
            }
        }
        affected.push(...getAffectedTiles(row, col, 'cross'));
        affected.push(...getAffectedTiles(row, col, 'diagonal'));
    } else if(pattern === 'void3x3') {
        affected.push(...getAffectedTiles(row, col, 'area3x3'));
    } else if(pattern === 'ring5x5') {
        for(let dr = -2; dr <= 2; dr++) {
            for(let dc = -2; dc <= 2; dc++) {
                if(Math.abs(dr) === 2 || Math.abs(dc) === 2) {
                    const nr = row + dr, nc = col + dc;
                    if(nr >= 0 && nr < GRID_SIZE && nc >= 0 && nc < GRID_SIZE) {
                        affected.push(`${nr},${nc}`);
                    }
                }
            }
        }
    }
    
    return affected;
}

function explodeBombs() {
    // FIRST: Clear destroyed tiles from PREVIOUS turn (so they lasted full turn!)
    const tilesToClearNext = new Set(destroyedTiles);
    destroyedTiles.clear();
    gameBoard.forEach(row => row.forEach(tile => tile.classList.remove('destroyed')));
    
    const allAffected = new Set();
    const lightning = [];
    
    bombs.forEach(bomb => {
        if(BOMB_TYPES[bomb.type].pattern === 'random') {
            const count = 3 + Math.floor(Math.random() * 5);
            const available = [];
            for(let r = 0; r < GRID_SIZE; r++) {
                for(let c = 0; c < GRID_SIZE; c++) {
                    const key = `${r},${c}`;
                    const hasBomb = bombs.some(b => b.row === r && b.col === c);
                    const hasPlayer = r === playerPos.row && c === playerPos.col;
                    if(!hasBomb && !hasPlayer && !destroyedTiles.has(key)) {
                        available.push(key);
                    }
                }
            }
            for(let i = 0; i < Math.min(count, available.length); i++) {
                const idx = Math.floor(Math.random() * available.length);
                lightning.push(available.splice(idx, 1)[0]);
            }
        } else {
            getAffectedTiles(bomb.row, bomb.col, BOMB_TYPES[bomb.type].pattern).forEach(k => allAffected.add(k));
        }
    });
    
    lightning.forEach(k => allAffected.add(k));
    
    const playerHit = allAffected.has(`${playerPos.row},${playerPos.col}`);
    
    playExplosionSound();
    createExplosions(allAffected);
    
    bombs.forEach(bomb => {
        if(BOMB_TYPES[bomb.type].pattern === 'void3x3') {
            getAffectedTiles(bomb.row, bomb.col, 'void3x3').forEach(key => {
                destroyedTiles.add(key);
                const [r, c] = key.split(',').map(Number);
                gameBoard[r][c].classList.add('destroyed');
            });
        }
    });
    
    lightning.forEach(key => {
        destroyedTiles.add(key);
        const [r, c] = key.split(',').map(Number);
        gameBoard[r][c].classList.add('destroyed');
    });
    
    setTimeout(() => {
        bombs.forEach(bomb => {
            const tile = gameBoard[bomb.row][bomb.col];
            const bombEl = tile.querySelector('.bomb');
            if(bombEl) tile.removeChild(bombEl);
        });
        
        if(playerHit) {
            endGame();
        } else {
            score += bombs.length * 10 + turn * 5;
            document.getElementById('score').textContent = score;
            
            turn++;
            document.getElementById('turn').textContent = turn;
            
            currentCountdownMax = Math.max(MIN_COUNTDOWN, INITIAL_COUNTDOWN - (turn - 1) * COUNTDOWN_DECREASE);
            
            setTimeout(() => startTurn(), 800);
        }
    }, 1200);
}

function playExplosionSound() {
    playSound(150, 0.25, 'sawtooth', 0.12);
    setTimeout(() => playSound(100, 0.2, 'sawtooth', 0.1), 40);
}

function createExplosions(affectedSet) {
    const layer = document.getElementById('explosionLayer');
    
    affectedSet.forEach(key => {
        const [r, c] = key.split(',').map(Number);
        const tile = gameBoard[r][c];
        const rect = tile.getBoundingClientRect();
        
        // MASSIVE WHITE FLASH
        const flash = document.createElement('div');
        flash.className = 'flash';
        flash.style.left = rect.left + 'px';
        flash.style.top = rect.top + 'px';
        flash.style.width = rect.width + 'px';
        flash.style.height = rect.height + 'px';
        layer.appendChild(flash);
        setTimeout(() => flash.remove(), 500);
        
        // EXPANDING RING EFFECT
        const ring = document.createElement('div');
        ring.style.position = 'absolute';
        ring.style.left = rect.left + rect.width/2 + 'px';
        ring.style.top = rect.top + rect.height/2 + 'px';
        ring.style.width = '10px';
        ring.style.height = '10px';
        ring.style.border = '3px solid #ff6600';
        ring.style.borderRadius = '50%';
        ring.style.transform = 'translate(-50%, -50%)';
        ring.style.animation = 'expandRing 0.6s ease-out forwards';
        ring.style.boxShadow = '0 0 15px #ff6600';
        layer.appendChild(ring);
        setTimeout(() => ring.remove(), 600);
        
        // FLAME CROSS - 4 directions
        for(let i = 0; i < 4; i++) {
            const flame = document.createElement('div');
            flame.className = 'particle';
            
            const angle = (i / 4) * Math.PI * 2;
            const dist = 80;
            
            flame.style.left = rect.left + rect.width/2 + 'px';
            flame.style.top = rect.top + rect.height/2 + 'px';
            flame.style.width = '12px';
            flame.style.height = '12px';
            flame.style.setProperty('--particle-color', '#ff3300');
            flame.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
            flame.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
            
            layer.appendChild(flame);
            setTimeout(() => flame.remove(), 900);
        }
        
        // SECONDARY FLAMES - diagonal
        for(let i = 0; i < 4; i++) {
            setTimeout(() => {
                const flame = document.createElement('div');
                flame.className = 'particle';
                
                const angle = (i / 4) * Math.PI * 2 + Math.PI/4;
                const dist = 60;
                
                flame.style.left = rect.left + rect.width/2 + 'px';
                flame.style.top = rect.top + rect.height/2 + 'px';
                flame.style.width = '10px';
                flame.style.height = '10px';
                flame.style.setProperty('--particle-color', '#ff9900');
                flame.style.setProperty('--tx', Math.cos(angle) * dist + 'px');
                flame.style.setProperty('--ty', Math.sin(angle) * dist + 'px');
                
                layer.appendChild(flame);
                setTimeout(() => flame.remove(), 700);
            }, 100);
        }
    });
}

// Add CSS for ring expansion
const style = document.createElement('style');
style.textContent = `
@keyframes expandRing {
    0% {
        width: 10px;
        height: 10px;
        opacity: 1;
    }
    100% {
        width: 80px;
        height: 80px;
        opacity: 0;
    }
}
`;
document.head.appendChild(style);

function endGame() {
    isGameOver = true;
    
    if(score > highScore) {
        highScore = score;
        localStorage.setItem('bomberman-high', highScore);
    }
    
    document.getElementById('finalScore').textContent = score;
    document.getElementById('finalTurn').textContent = turn;
    document.getElementById('finalHigh').textContent = highScore;
    document.getElementById('gameOver').style.display = 'block';
    
    playSound(200, 0.4, 'sawtooth', 0.15);
}

function restartGame() {
    isGameOver = false;
    score = 0;
    turn = 1;
    playerPos = { row: 4, col: 4 };
    bombs = [];
    destroyedTiles.clear();
    currentCountdownMax = INITIAL_COUNTDOWN;
    
    document.getElementById('score').textContent = 0;
    document.getElementById('turn').textContent = 1;
    document.getElementById('gameOver').style.display = 'none';
    
    createBoard();
    startTurn();
    
    playSound(600, 0.15);
}

init();
</script>

</body>
</html>