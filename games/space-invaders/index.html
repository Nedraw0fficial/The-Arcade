<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GALACTIC INVADERS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body { background: #0a0a0f; display: flex; align-items: center; justify-content: center; font-family: 'Courier New', monospace; }
        .wrap { position: relative; }
        canvas { display: block; background: #000; border: 3px solid #00ff00; box-shadow: 0 0 30px rgba(0,255,0,0.5); image-rendering: pixelated; }
        .ui { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; font-size: 18px; color: #00ff00; text-shadow: 0 0 8px #00ff00; z-index: 10; }
        .hp-bar { position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); width: 300px; height: 20px; background: #300; border: 2px solid #00ff00; z-index: 10; }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); box-shadow: 0 0 10px #00ff00; transition: width 0.3s; }
        .over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 50px 70px; border: 3px solid #ff0000; box-shadow: 0 0 40px rgba(255,0,0,0.6); text-align: center; display: none; z-index: 20; border-radius: 8px; }
        .over h2 { font-size: 40px; color: #ff0000; text-shadow: 0 0 20px #ff0000; margin-bottom: 20px; }
        .over p { font-size: 20px; color: #00ffff; text-shadow: 0 0 10px #00ffff; margin-bottom: 30px; }
        .over button { background: transparent; border: 2px solid #00ff00; color: #00ff00; padding: 15px 40px; font-size: 18px; cursor: pointer; font-family: 'Courier New'; text-shadow: 0 0 5px #00ff00; transition: all 0.3s; border-radius: 4px; }
        .over button:hover { background: #00ff00; color: #000; transform: scale(1.05); }
        .wave { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 56px; color: #00ffff; text-shadow: 0 0 30px #00ffff; z-index: 15; display: none; animation: w 2s; }
        @keyframes w { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); } }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="ui">
            <div>SCORE: <span id="s">0</span></div>
            <div>HIGH: <span id="h">0</span></div>
            <div>WAVE: <span id="w">1</span></div>
        </div>
        <canvas id="c"></canvas>
        <div class="hp-bar"><div class="hp-fill" id="hp" style="width:100%"></div></div>
        <div class="wave" id="wt">WAVE 1</div>
        <div class="over" id="over">
            <h2>GAME OVER</h2>
            <p id="fs">FINAL SCORE: 0</p>
            <button onclick="restart()">PLAY AGAIN</button>
        </div>
    </div>
    <script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const W=900, H=700;
c.width=W; c.height=H;

function resize() {
    const scale = Math.min(window.innerWidth/W, window.innerHeight/H)*0.5;
    c.style.width=(W*scale)+'px';
    c.style.height=(H*scale)+'px';
}
resize();
window.addEventListener('resize',resize);

// Types with EXACT specs
const TYPES = {
    SCOUT: {hp:1,col:'#39FF14',sz:32,pts:10,dmg:1,fire:0.0012,wt:100},
    ZAP: {hp:1,col:'#00ffff',sz:26,pts:25,dmg:1,fire:0.0004,wt:35},
    TANK: {hp:5,col:'#ff0000',sz:48,pts:50,dmg:3,fire:0.00025,wt:15},
    SPLITTER: {hp:2,col:'#ffff00',sz:34,pts:40,dmg:1,fire:0.00045,wt:25,split:true},
    BOMBER: {hp:3,col:'#ff00ff',sz:42,pts:60,dmg:5,fire:0.0003,wt:10},
    ELITE: {hp:4,col:'#ff8800',sz:38,pts:100,dmg:2,fire:0.0004,wt:5},
    BOSS: {hp:10,col:'#ffffff',sz:70,pts:500,dmg:5,fire:0.001,wt:1}
};

let player,bullets,eBullets,enemies,particles,stars,shields,powerups;
let score,high,wave,hp,gameOver,keys,moveDir,moveTimer,dropDist;
let shakeX,shakeY,shakeInt,rapidFire,rapidTimer,projectileBoost,boostTimer,spacePressed;

let audioCtx;
function initAudio(){audioCtx=new(window.AudioContext||window.webkitAudioContext)();}
function tone(f,d,t='square',v=0.1){
    if(!audioCtx)initAudio();
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.connect(g);g.connect(audioCtx.destination);
    o.frequency.value=f;o.type=t;
    g.gain.setValueAtTime(v,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+d);
    o.start();o.stop(audioCtx.currentTime+d);
}

function init() {
    player={x:450,y:650,w:45,h:28,spd:450,dx:0,hp:10,maxHp:10};
    bullets=[]; eBullets=[]; enemies=[]; particles=[]; powerups=[];
    stars=[]; score=0; high=parseInt(localStorage.getItem('inv-high'))||0;
    wave=1; hp=10; gameOver=false; keys={}; moveDir=1; moveTimer=0; dropDist=25;
    shakeX=shakeY=shakeInt=0; rapidFire=false; rapidTimer=0; projectileBoost=false; boostTimer=0; spacePressed=false;
    
    for(let i=0;i<120;i++) stars.push({x:Math.random()*W,y:Math.random()*H,sz:1+Math.random()*2,spd:0.3+Math.random(),br:0.3+Math.random()*0.7});
    
    // Proper shields
    shields=[];
    const sy=580;
    for(let i=0;i<3;i++) {
        const sx=150+i*300;
        const shield={x:sx,y:sy,w:90,h:70,pix:[]};
        for(let y=0;y<shield.h;y++) {
            shield.pix[y]=[];
            for(let x=0;x<shield.w;x++) {
                const dx=(x-shield.w/2)/(shield.w/2);
                const dy=y/shield.h;
                const curve = dy<0.5 ? Math.sqrt(1-dx*dx) : 1;
                shield.pix[y][x] = (dy<0.5 ? (1-dy/0.5)<curve : dy<0.85) ? 1:0;
            }
        }
        shields.push(shield);
    }
    
    document.getElementById('h').textContent=high;
    spawnWave();
}

function spawnWave() {
    enemies=[];
    const isBoss = wave%5===0;
    
    // Weight system
    const weights={};
    Object.keys(TYPES).forEach(k=>{
        const t=TYPES[k];
        let w=t.wt;
        if(wave<=2) {
            if(k==='SCOUT')w=200;
            if(k==='ZAP')w=40;
            if(k==='TANK')w=10;
            if(k==='SPLITTER')w=20;
            if(k==='BOMBER'||k==='ELITE'||k==='BOSS')w=0;
        } else if(wave<=4) {
            if(k==='SCOUT')w=150;
            if(k==='ZAP')w=60;
            if(k==='TANK')w=25;
            if(k==='SPLITTER')w=35;
            if(k==='BOMBER')w=15;
            if(k==='ELITE')w=5;
            if(k==='BOSS')w=0;
        } else if(wave<=7) {
            if(k==='SCOUT')w=100;
            if(k==='ZAP')w=50;
            if(k==='TANK')w=35;
            if(k==='SPLITTER')w=40;
            if(k==='BOMBER')w=25;
            if(k==='ELITE')w=15;
            if(k==='BOSS')w=3;
        } else {
            w=t.wt+(wave-8)*(k==='BOSS'?2:k==='ELITE'?3:0);
            if(k==='SCOUT')w=Math.max(40,100-(wave-8)*5);
        }
        weights[k]=w;
    });
    
    if(isBoss) {
        enemies.push(createEnemy('BOSS',W/2-32,50));
        for(let i=0;i<6;i++) enemies.push(createEnemy('ELITE',100+i*130,100));
    } else {
        const rows=Math.min(4+Math.floor(wave/3),6);
        const cols=9;
        const groupW=cols*70;
        const startX=(W-groupW)/2+35;
        for(let r=0;r<rows;r++) {
            for(let c=0;c<cols;c++) {
                const type=pickWeighted(weights);
                const t=TYPES[type];
                enemies.push(createEnemy(type,startX+c*70,40+r*55));
            }
        }
    }
    
    document.getElementById('w').textContent=wave;
    showWave();
}

function pickWeighted(weights) {
    const arr=[];
    Object.keys(weights).forEach(k=>{
        for(let i=0;i<weights[k];i++)arr.push(k);
    });
    return arr[Math.floor(Math.random()*arr.length)];
}

function createEnemy(type,x,y) {
    const t=TYPES[type];
    return {type,x,y,w:t.sz,h:t.sz,hp:t.hp,maxHp:t.hp,col:t.col,pts:t.pts,dmg:t.dmg,fire:t.fire*(1+wave*0.05),proj:t.proj,split:t.split||false};
}

function showWave() {
    const wt=document.getElementById('wt');
    wt.textContent=wave%5===0?'⚠ BOSS WAVE ⚠':`WAVE ${wave}`;
    wt.style.display='block';
    wt.style.animation='none';
    setTimeout(()=>wt.style.animation='w 2s',10);
    setTimeout(()=>wt.style.display='none',2000);
}

function shake(i){shakeInt=i;}

function parts(x,y,col,n=15) {
    for(let i=0;i<n;i++) {
        const ang=Math.PI*2*i/n+(Math.random()-0.5)*0.5;
        const spd=100+Math.random()*200;
        particles.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:1,sz:2+Math.random()*3,col});
    }
}

function update(dt) {
    if(gameOver)return;
    
    stars.forEach(s=>{s.y+=s.spd*dt;if(s.y>H){s.y=0;s.x=Math.random()*W;}});
    
    if(rapidFire){rapidTimer-=dt;if(rapidTimer<=0){rapidFire=false;tone(150,0.2);}}
    if(projectileBoost){boostTimer-=dt;if(boostTimer<=0){projectileBoost=false;tone(200,0.2);}}
    
    // Player
    if(keys['ArrowLeft']||keys['a'])player.x=Math.max(0,player.x-player.spd*dt);
    if(keys['ArrowRight']||keys['d'])player.x=Math.min(W-player.w,player.x+player.spd*dt);
    
    // Bullets
    bullets=bullets.filter(b=>{
        b.y-=700*dt;
        if(b.y<0)return false;
        for(let i=enemies.length-1;i>=0;i--) {
            const e=enemies[i];
            if(b.x>e.x-8&&b.x<e.x+e.w+8&&b.y>e.y-8&&b.y<e.y+e.h+8) {
                e.hp-=(projectileBoost?2:1);
                parts(b.x,b.y,e.col,12);
                tone(800,0.06);
                if(e.hp<=0) {
                    score+=e.pts;
                    document.getElementById('s').textContent=score;
                    if(score>high){high=score;localStorage.setItem('inv-high',high);document.getElementById('h').textContent=high;}
                    tone(280,0.2,'sawtooth');
                    parts(e.x+e.w/2,e.y+e.h/2,e.col,30);
                    shake(e.type==='BOSS'?30:8);
                    if(e.type==='BOSS')tone(100,0.5,'sawtooth',0.3);
                    if(e.type==='BOSS')tone(100,0.5,'sawtooth',0.3);
                    if(e.split&&Math.random()<0.5) {
                        enemies.push(createEnemy('SCOUT',e.x-25,e.y));
                        enemies.push(createEnemy('SCOUT',e.x+25,e.y));
                    }
                    if(Math.random()<0.08) {
                        const typeWeights={rapid:20,shield:25,nuke:2,heal:20};
                        const typeArr=[];
                        Object.keys(typeWeights).forEach(t=>{
                            for(let i=0;i<typeWeights[t];i++)typeArr.push(t);
                        });
                        const type=typeArr[Math.floor(Math.random()*typeArr.length)];
                        powerups.push({type:type,x:e.x,y:e.y,spd:180});
                    }
                    enemies.splice(i,1);
                }
            }
        }
        return true;
    });
    
    // Enemy bullets with PROPER angle movement
    eBullets=eBullets.filter(b=>{
        // Handle different bullet types
        if(b.vx!==undefined&&b.vy!==undefined) {
            // Angled shots
            b.x+=b.vx*dt;
            b.y+=b.vy*dt;
        } else {
            // Standard vertical
            b.y+=(b.spd||350)*dt;
        }
        
        // Homing behavior with deviation limit
        if(b.homing&&player) {
            const dx=(player.x+player.w/2)-b.x;
            const currentAngle=b.angle||0;
            const targetAngle=Math.atan2(dx,100);
            const maxDev=b.maxDeviation||0.5;
            const newAngle=Math.max(-maxDev,Math.min(maxDev,targetAngle));
            b.angle=newAngle;
            b.x+=Math.sin(newAngle)*100*dt;
        }
        
        if(b.y>H||b.x<-50||b.x>W+50)return false;
        
        // Hit player
        if(b.x>player.x&&b.x<player.x+player.w&&b.y>player.y&&b.y<player.y+player.h) {
            player.hp-=b.dmg||1;
            document.getElementById('hp').style.width=(player.hp/player.maxHp*100)+'%';
            parts(b.x,b.y,'#ff0000',20);
            shake(15);
            tone(100,0.4,'triangle',0.25);
            if(player.hp<=0)endGame();
            return false;
        }
        
        // Hit shield
        for(let s of shields) {
            const sx=Math.floor(b.x-s.x);
            const sy=Math.floor(b.y-s.y);
            if(sx>=0&&sx<s.w&&sy>=0&&sy<s.h&&s.pix[sy]&&s.pix[sy][sx]) {
                const rad=b.bombRadius||4;
                for(let dy=-rad;dy<=rad;dy++) {
                    for(let dx=-rad;dx<=rad;dx++) {
                        const px=sx+dx, py=sy+dy;
                        if(px>=0&&px<s.w&&py>=0&&py<s.h&&s.pix[py]&&Math.sqrt(dx*dx+dy*dy)<=rad) s.pix[py][px]=0;
                    }
                }
                parts(b.x,b.y,'#00ff00',12);
                tone(400,0.1);
                return false;
            }
        }
        return true;
    });
    
    // Typewriter movement for ALL aliens + individual patterns
    moveTimer+=dt*1000;
    const moveInt=Math.max(700,1700-wave*12);
    if(moveTimer>=moveInt) {
        moveTimer=0;
        let hitEdge=false;
        enemies.forEach(e=>{
            e.x+=65*moveDir;
            if(e.x<=15||e.x+e.w>=W-15)hitEdge=true;
        });
        if(hitEdge) {
            moveDir*=-1;
            enemies.forEach(e=>e.y+=dropDist);
            dropDist=Math.min(35,dropDist+2);
        }
    }
    
    // Individual patterns ON TOP of typewriter
    enemies.forEach(e=>{
        if(!e.angle)e.angle=Math.random()*Math.PI*2;
        if(!e.patternTimer)e.patternTimer=0;
        if(!e.dir)e.dir=Math.random()>0.5?1:-1;
        e.angle+=dt*3;
        e.patternTimer+=dt;
        
        if(e.type==='SCOUT') {
            // No extra movement
        } else if(e.type==='ZAP') {
            // Fast left-right
            e.x+=Math.sin(e.angle*2.5)*200*dt;
        } else if(e.type==='TANK') {
            // Slow left-right
            e.x+=Math.sin(e.angle)*40*dt;
        } else if(e.type==='SPLITTER') {
            // Wave pattern
            e.x+=Math.sin(e.angle*1.5)*80*dt;
        } else if(e.type==='BOMBER') {
            // Random erratic movement + hide behind aliens
            if(e.patternTimer>1.5) {
                e.patternTimer=0;
                e.dir=Math.random()<0.5?1:-1;
                if(Math.random()<0.3)e.dir=0; // Sometimes move back up
            }
            e.x+=e.dir*100*dt;
            if(e.dir===0)e.y-=50*dt; // Move up
            
            // Hide behind nearby aliens (prefer tanks)
            const nearby=enemies.find(a=>a!==e&&Math.abs(a.x-e.x)<100&&a.y<e.y&&a.y>e.y-80);
            if(nearby) {
                const dx=(nearby.x+nearby.w/2)-(e.x+e.w/2);
                e.x+=Math.sign(dx)*80*dt;
            }
        } else if(e.type==='ELITE') {
            // Fast chaotic movement
            e.x+=Math.cos(e.angle*2)*180*dt;
            e.y+=Math.sin(e.angle)*60*dt;
        } else if(e.type==='BOSS') {
            // Slow horizontal wave
            e.y=Math.max(80,Math.min(200,e.y+Math.sin(e.angle*0.3)*40*dt));
        }
        
        if(e.y+e.h>=H-100)endGame();
    });
    
    // Aliens shoot with PROPER attack patterns
    enemies.forEach(e=>{
        if(Math.random()<e.fire*dt*60) {
            const cx=e.x+e.w/2, cy=e.y+e.h;
            const px=player.x+player.w/2;
            
            if(e.type==='SCOUT') {
                // Basic single shot
                eBullets.push({x:cx,y:cy,dmg:2,spd:350,type:'normal'});
            } else if(e.type==='ZAP') {
                // 3 fast projectiles in quick succession with slight delay
                for(let i=0;i<3;i++) {
                    setTimeout(()=>{
                        if(!gameOver)eBullets.push({x:cx,y:cy,dmg:1,spd:500,type:'zap',size:3});
                    },i*100);
                }
            } else if(e.type==='TANK') {
                // Big slow projectile
                eBullets.push({x:cx,y:cy,dmg:3,spd:220,bombRadius:18,type:'tank',size:8});
            } else if(e.type==='SPLITTER') {
                // Fast single shot
                eBullets.push({x:cx,y:cy,dmg:2,spd:480,type:'fast',size:5});
            } else if(e.type==='BOMBER') {
                // Heavy bomb
                eBullets.push({x:cx,y:cy,dmg:4,spd:200,bombRadius:20,type:'bomb',size:10});
            } else if(e.type==='ELITE') {
                // 3 homing spread shots at ANGLES
                for(let i=-1;i<=1;i++) {
                    const angle=i*0.3; // 0.3 radians spread
                    eBullets.push({
                        x:cx,y:cy,dmg:3,spd:450,
                        homing:true,maxDeviation:0.5,
                        vx:Math.sin(angle)*100,
                        angle:angle,
                        type:'elite',size:6
                    });
                }
            } else if(e.type==='BOSS') {
                const pattern=Math.floor(Math.random()*4);
                if(pattern===0) { // Produce
                    if(enemies.length<35) {
                        for(let i=0;i<2;i++) {
                            const side=i===0?-1:1;
                            enemies.push(createEnemy('SCOUT',e.x+side*e.w*0.6,e.y+e.h));
                        }
                    }
                } else if(pattern===1) { // Bombing
                    for(let i=-2;i<=2;i++) {
                        eBullets.push({x:cx+i*20,y:cy,dmg:5,spd:180,bombRadius:18,type:'bossBomb',size:12});
                    }
                } else if(pattern===2) { // Shoot-out - REAL SPREAD
                    for(let i=-4;i<=4;i++) {
                        const angle=i*0.25; // Wider spread
                        eBullets.push({
                            x:cx,y:cy,dmg:1,spd:550,
                            vx:Math.sin(angle)*200,
                            vy:Math.cos(angle)*550,
                            type:'bossSpread',size:4
                        });
                    }
                } else { // Direct shot - Aimed at player
                    const angle=Math.atan2(player.y-e.y,px-cx);
                    for(let i=0;i<3;i++) {
                        eBullets.push({
                            x:cx,y:cy,dmg:3,spd:500,
                            vx:Math.sin(angle)*500,
                            vy:Math.cos(angle)*500,
                            bombRadius:6,
                            type:'bossDirect',size:7
                        });
                    }
                }
            }
        }
    });
    
    // Powerups
    powerups=powerups.filter(p=>{
        p.y+=p.spd*dt;
        if(p.y>H)return false;
        if(p.x>player.x&&p.x<player.x+player.w&&p.y>player.y&&p.y<player.y+player.h) {
            if(p.type==='shield') {
                shields.forEach(s=>{
                    for(let y=0;y<s.h;y++)for(let x=0;x<s.w;x++){
                        const dx=(x-s.w/2)/(s.w/2),dy=y/s.h;
                        const curve=dy<0.5?Math.sqrt(1-dx*dx):1;
                        if(dy<0.5?(1-dy/0.5)<curve:dy<0.85)s.pix[y][x]=1;
                    }
                });
            } else if(p.type==='nuke') {
                enemies.forEach(e=>{score+=e.pts;parts(e.x+e.w/2,e.y+e.h/2,e.col,20);});
                document.getElementById('s').textContent=score;
                enemies=[];
                shake(35);
                tone(140,0.7,'sawtooth');
            } else if(p.type==='heal') {
                player.hp=Math.min(player.maxHp,player.hp+1);
                document.getElementById('hp').style.width=(player.hp/player.maxHp*100)+'%';
            } else if(p.type==='rapid') {
                projectileBoost=true;boostTimer=6;
            }
            const col=p.type==='heal'?'#ff0000':p.type==='rapid'?'#ffff00':p.type==='shield'?'#00ff00':'#ff00ff';
            parts(p.x,p.y,col,15);
            tone(950,0.25,'sine');
            if(p.type==='nuke')tone(500,0.8,'sawtooth',0.2);
            if(p.type==='nuke')tone(500,0.8,'sawtooth',0.2);
            return false;
        }
        return true;
    });
    
    // Particles
    particles=particles.filter(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=300*dt;p.life-=dt*2.5;return p.life>0;});
    
    // Shake
    if(shakeInt>0){shakeX=(Math.random()-0.5)*shakeInt;shakeY=(Math.random()-0.5)*shakeInt;shakeInt*=0.85;if(shakeInt<0.1){shakeInt=0;shakeX=shakeY=0;}}
    
    // Wave clear
    if(enemies.length===0) {wave++;tone(523,0.3,'sine');tone(659,0.3,'sine');spawnWave();}
}

function endGame() {
    gameOver=true;
    document.getElementById('fs').textContent=`FINAL SCORE: ${score}`;
    document.getElementById('over').style.display='block';
    tone(220,1,'sawtooth',0.15);
}

function restart() {
    document.getElementById('over').style.display='none';
    init();
}

function draw() {
    ctx.save();
    ctx.translate(shakeX,shakeY);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,W,H);
    
    // Stars
    stars.forEach(s=>{ctx.globalAlpha=s.br;ctx.fillStyle='#fff';ctx.fillRect(s.x,s.y,s.sz,s.sz);});
    ctx.globalAlpha=1;
    
    // Shields - OPTIMIZED with path batching
    ctx.fillStyle='#00ff00';
    ctx.shadowBlur=10;
    ctx.shadowColor='#00ff00';
    shields.forEach(s=>{
        ctx.beginPath();
        for(let y=0;y<s.h;y++)for(let x=0;x<s.w;x++)if(s.pix[y][x])ctx.rect(s.x+x,s.y+y,1,1);
        ctx.fill();
    });
    ctx.shadowBlur=0;
    
    // Player - SLEEK BADASS spaceship
    const px=player.x+player.w/2, py=player.y;
    ctx.fillStyle='#00ff00';
    ctx.shadowBlur=25;
    ctx.shadowColor='#00ff00';
    // Main body - sharp angular design
    ctx.beginPath();
    ctx.moveTo(px,py); // Sharp nose
    ctx.lineTo(px-14,py+12);
    ctx.lineTo(px-10,py+18);
    ctx.lineTo(px-6,py+28);
    ctx.lineTo(px+6,py+28);
    ctx.lineTo(px+10,py+18);
    ctx.lineTo(px+14,py+12);
    ctx.closePath();
    ctx.fill();
    // Wing details
    ctx.fillStyle='#00ffff';
    ctx.beginPath();
    ctx.moveTo(px-14,py+12);
    ctx.lineTo(px-20,py+14);
    ctx.lineTo(px-16,py+18);
    ctx.lineTo(px-10,py+18);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(px+14,py+12);
    ctx.lineTo(px+20,py+14);
    ctx.lineTo(px+16,py+18);
    ctx.lineTo(px+10,py+18);
    ctx.closePath();
    ctx.fill();
    // Cockpit glow
    ctx.fillStyle='#ffffff';
    ctx.beginPath();
    ctx.arc(px,py+8,3,0,Math.PI*2);
    ctx.fill();
    // Engine glows
    ctx.fillStyle='#00ffff';
    ctx.shadowBlur=20;
    ctx.shadowColor='#00ffff';
    for(let i=-1;i<=1;i+=2) {
        ctx.beginPath();
        ctx.ellipse(px+i*5,py+28,3,5,0,0,Math.PI*2);
        ctx.fill();
    }
    ctx.shadowBlur=0;
    
    // Bullets
    bullets.forEach(b=>{
        ctx.fillStyle=b.boosted?'#ff00ff':(rapidFire?'#ffff00':'#00ffff');
        ctx.shadowBlur=10;
        ctx.shadowColor=ctx.fillStyle;
        ctx.fillRect(b.x-2,b.y,4,12);
    });
    ctx.shadowBlur=0;
    
    // Enemy bullets - COOL AS FUCK
    eBullets.forEach(b=>{
        const sz=b.size||4;
        
        if(b.type==='zap') {
            // Small fast cyan bolts
            ctx.fillStyle='#00ffff';
            ctx.shadowBlur=15;
            ctx.shadowColor='#00ffff';
            ctx.fillRect(b.x-sz/2,b.y-2,sz,8);
            ctx.globalAlpha=0.5;
            ctx.fillRect(b.x-sz,b.y-4,sz*2,12);
            ctx.globalAlpha=1;
        } else if(b.type==='tank'||b.type==='bomb'||b.type==='bossBomb') {
            // Heavy bombs
            const col=b.type==='bossBomb'?'#ffffff':b.type==='bomb'?'#ff00ff':'#ff6600';
            ctx.fillStyle=col;
            ctx.shadowBlur=20;
            ctx.shadowColor=col;
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            ctx.globalAlpha=0.3;
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz*2,0,Math.PI*2);
            ctx.fill();
            ctx.globalAlpha=1;
        } else if(b.type==='elite') {
            // Homing orange projectiles
            ctx.fillStyle='#ff8800';
            ctx.shadowBlur=18;
            ctx.shadowColor='#ff8800';
            // Trail
            ctx.globalAlpha=0.6;
            for(let i=1;i<=3;i++) {
                ctx.beginPath();
                ctx.arc(b.x,b.y+i*5,sz-i,0,Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha=1;
            // Main
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            ctx.fillStyle='#ffffff';
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz*0.4,0,Math.PI*2);
            ctx.fill();
        } else if(b.type==='bossSpread') {
            // Fast spread shots
            ctx.fillStyle='#ffffff';
            ctx.shadowBlur=12;
            ctx.shadowColor='#ffffff';
            ctx.fillRect(b.x-sz/2,b.y-sz/2,sz,sz*2);
            ctx.globalAlpha=0.5;
            ctx.fillRect(b.x-sz,b.y-sz,sz*2,sz*3);
            ctx.globalAlpha=1;
        } else if(b.type==='bossDirect') {
            // Aimed deadly shots
            ctx.fillStyle='#ff0000';
            ctx.shadowBlur=20;
            ctx.shadowColor='#ff0000';
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            ctx.fillStyle='#ffffff';
            ctx.fillRect(b.x-1,b.y-sz,2,sz*2);
        } else if(b.type==='fast') {
            // Splitter fast shot
            ctx.fillStyle='#ffff00';
            ctx.shadowBlur=15;
            ctx.shadowColor='#ffff00';
            ctx.fillRect(b.x-sz/2,b.y,sz,12);
        } else {
            // Normal shots
            ctx.fillStyle='#ff0000';
            ctx.shadowBlur=12;
            ctx.shadowColor='#ff0000';
            ctx.fillRect(b.x-2,b.y,4,10);
        }
        ctx.shadowBlur=0;
        ctx.globalAlpha=1;
    });
    
    // Enemies - COOL but recognizable designs
    enemies.forEach(e=>{
        const cx=e.x+e.w/2, cy=e.y+e.h/2, s=e.w;
        const pulse=Math.sin(performance.now()/200+e.x)*0.15+0.85;
        
        ctx.fillStyle=e.col;
        ctx.shadowBlur=18*pulse;
        ctx.shadowColor=e.col;
        
        if(e.type==='BOSS') {
            // BOSS - Massive carrier mothership (8-bit)
            const px=5.5, py=4;
            // Main body
            ctx.fillRect(cx-px*3,cy-py*1.5,px*6,py*3);
            // Bridge tower
            ctx.fillRect(cx-px*1,cy-py*3,px*2,py*1.5);
            // Top turrets (AA)
            ctx.fillRect(cx-px*2.5,cy-py*2.5,px,py*0.75);
            ctx.fillRect(cx+px*1.5,cy-py*2.5,px,py*0.75);
            // Side sections
            ctx.fillRect(cx-px*3.5,cy-py*0.5,px,py*2);
            ctx.fillRect(cx+px*2.5,cy-py*0.5,px,py*2);
            // Engine ports
            ctx.fillRect(cx-px*2,cy+py*1.5,px,py);
            ctx.fillRect(cx-px*0.2,cy+py*1.5,px,py);
            ctx.fillRect(cx+px*1.8,cy+py*1.5,px,py);
            // Weapon bay (bottom)
            ctx.fillRect(cx-px*1.5,cy+py*2.5,px*3,py*0.75);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.6,cy-py*0.5,px*0.5,py*0.6);
            ctx.fillRect(cx+px*0.1,cy-py*0.5,px*0.5,py*0.6);
            ctx.fillStyle=e.col;
        } else if(e.type==='SCOUT') {
            // SCOUT - Classic squid invader (8-bit)
            const px=4, py=3; // Pixel size
            // Head
            ctx.fillRect(cx-px*2,cy-py*3,px*4,py*2);
            ctx.fillRect(cx-px*3,cy-py*1.5,px*6,py*2);
            // Body
            ctx.fillRect(cx-px*2.5,cy+py*0.5,px*5,py*2);
            // Side fins
            ctx.fillRect(cx-px*4,cy-py*0.5,px,py*2.5);
            ctx.fillRect(cx+px*3,cy-py*0.5,px,py*2.5);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*1.5,cy-py*1.5,px,py);
            ctx.fillRect(cx+px*0.5,cy-py*1.5,px,py);
            ctx.fillStyle=e.col;
        } else if(e.type==='ZAP') {
            // ZAP - Classic crab invader (8-bit)
            const px=3.5, py=3;
            // Main body
            ctx.fillRect(cx-px*2,cy-py*2,px*4,py*2);
            ctx.fillRect(cx-px*2.5,cy,px*5,py*1.5);
            // Side arms
            ctx.fillRect(cx-px*3.5,cy-py,px,py*3);
            ctx.fillRect(cx+px*2.5,cy-py,px,py*3);
            // Top bumps
            ctx.fillRect(cx-px*1.5,cy-py*3,px,py);
            ctx.fillRect(cx+px*0.5,cy-py*3,px,py);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.8,cy-py*1.5,px*0.6,py*0.6);
            ctx.fillRect(cx+px*0.2,cy-py*1.5,px*0.6,py*0.6);
            ctx.fillStyle=e.col;
        } else if(e.type==='TANK') {
            // TANK - Heavy invader (8-bit)
            const px=4, py=3;
            // Main body
            ctx.fillRect(cx-px*2,cy-py*1.5,px*4,py*3);
            // Top section
            ctx.fillRect(cx-px*1.5,cy-py*2.5,px*3,py);
            // Side cannons
            ctx.fillRect(cx-px*2.5,cy-py*0.5,px,py*2);
            ctx.fillRect(cx+px*1.5,cy-py*0.5,px,py*2);
            // Center cannon
            ctx.fillRect(cx-px*0.5,cy-py*2.5,px,py*1.5);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.8,cy-py*0.5,px*0.6,py*0.6);
            ctx.fillRect(cx+px*0.2,cy-py*0.5,px*0.6,py*0.6);
            ctx.fillStyle=e.col;
        } else if(e.type==='SPLITTER') {
            // SPLITTER - Ghost UFO (8-bit)
            const px=4, py=3;
            // Main body (half circle look)
            ctx.fillRect(cx-px*2,cy-py*1.5,px*4,py*1.5);
            ctx.fillRect(cx-px*2.5,cy,px*5,py*1.5);
            // Bumps on top
            ctx.fillRect(cx-px*2,cy-py*2,px,py*0.75);
            ctx.fillRect(cx-px*0.5,cy-py*2,px,py*0.75);
            ctx.fillRect(cx+px*1,cy-py*2,px,py*0.75);
            // Bottom tendrils
            ctx.fillRect(cx-px*1.5,cy+py*1.5,px*0.8,py);
            ctx.fillRect(cx+px*0.7,cy+py*1.5,px*0.8,py);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.8,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillRect(cx+px*0.2,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillStyle=e.col;
        } else if(e.type==='BOMBER') {
            // BOMBER - Large mothership (8-bit)
            const px=4.5, py=3;
            // Main body
            ctx.fillRect(cx-px*2.5,cy-py,px*5,py*2);
            // Top section
            ctx.fillRect(cx-px*2,cy-py*2.5,px*4,py*1);
            // Cargo sections
            ctx.fillRect(cx-px*2,cy+py*1,px*1.2,py);
            ctx.fillRect(cx-px*0.3,cy+py*1,px*1.2,py);
            ctx.fillRect(cx+px*1.3,cy+py*1,px*1.2,py);
            // Bottom thrusters
            ctx.fillRect(cx-px*1.8,cy+py*2,px,py*0.8);
            ctx.fillRect(cx+px*0.8,cy+py*2,px,py*0.8);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.8,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillRect(cx+px*0.2,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillStyle=e.col;
        } else if(e.type==='ELITE') {
            // ELITE - Advanced fighter (8-bit)
            const px=3.5, py=3;
            // Main body
            ctx.fillRect(cx-px*2,cy-py,px*4,py*2);
            // Top armor
            ctx.fillRect(cx-px*1.5,cy-py*2.5,px*3,py*0.75);
            // Wings
            ctx.fillRect(cx-px*3,cy-py*0.5,px*0.8,py*2);
            ctx.fillRect(cx+px*2.2,cy-py*0.5,px*0.8,py*2);
            // Center spike
            ctx.fillRect(cx-px*0.4,cy-py*2.5,px*0.8,py);
            // Bottom thrusters
            ctx.fillRect(cx-px*1.2,cy+py*1,px,py*0.75);
            ctx.fillRect(cx+px*0.2,cy+py*1,px,py*0.75);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*0.8,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillRect(cx+px*0.2,cy-py*0.3,px*0.6,py*0.6);
            ctx.fillStyle=e.col;
        }
        
        ctx.shadowBlur=0;
        
        // HP bar
        if(e.hp<e.maxHp) {
            const bw=e.w-8;
            ctx.fillStyle='#600';
            ctx.fillRect(e.x+4,e.y-8,bw,3);
            ctx.fillStyle='#0f0';
            ctx.fillRect(e.x+4,e.y-8,bw*(e.hp/e.maxHp),3);
        }
    });
    
    // Powerups
    powerups.forEach(p=>{
        const col=p.type==='heal'?'#ff0000':p.type==='rapid'?'#ffff00':p.type==='shield'?'#00ff00':'#ff00ff';
        ctx.fillStyle=col;
        ctx.shadowBlur=15;
        ctx.shadowColor=col;
        ctx.fillRect(p.x-12,p.y-12,24,24);
        ctx.shadowBlur=0;
    });
    
    // Particles
    particles.forEach(p=>{ctx.globalAlpha=p.life;ctx.fillStyle=p.col;ctx.fillRect(p.x-p.sz/2,p.y-p.sz/2,p.sz,p.sz);});
    ctx.globalAlpha=1;
    
    ctx.restore();
}

// Controls
document.addEventListener('keydown',e=>{
    keys[e.key]=true;
    if(e.key===' '&&!gameOver&&!spacePressed&&bullets.length<(rapidFire?8:5)) {
        spacePressed=true;
        bullets.push({x:player.x+player.w/2,y:player.y,boosted:projectileBoost});
        tone(1000,0.1);
    }
});
document.addEventListener('keyup',e=>{
    keys[e.key]=false;
    if(e.key===' ')spacePressed=false;
});

// Loop
let lastTime=performance.now();
function loop(t) {
    const dt=Math.min((t-lastTime)/1000,0.1);
    lastTime=t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

init();
loop(performance.now());
    </script>
</body>
</html>