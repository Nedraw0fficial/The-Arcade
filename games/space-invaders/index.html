<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GALACTIC INVADERS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        body { background: #0a0a0f; display: flex; align-items: center; justify-content: center; font-family: 'Courier New', monospace; }
        .wrap { position: relative; }
        canvas { display: block; background: #000; border: 3px solid #00ff00; box-shadow: 0 0 30px rgba(0,255,0,0.5); image-rendering: pixelated; }
        .ui { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); display: flex; gap: 40px; font-size: 18px; color: #00ff00; text-shadow: 0 0 8px #00ff00; z-index: 10; }
        .hp-bar { position: absolute; top: 10px; left: 15px; width: 200px; height: 18px; background: #300; border: 2px solid #00ff00; z-index: 10; }
        .hp-fill { height: 100%; background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00); box-shadow: 0 0 10px #00ff00; transition: width 0.3s; }
        .over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); padding: 50px 70px; border: 3px solid #ff0000; box-shadow: 0 0 40px rgba(255,0,0,0.6); text-align: center; display: none; z-index: 20; border-radius: 8px; }
        .over h2 { font-size: 40px; color: #ff0000; text-shadow: 0 0 20px #ff0000; margin-bottom: 20px; }
        .over p { font-size: 20px; color: #00ffff; text-shadow: 0 0 10px #00ffff; margin-bottom: 30px; }
        .over button { background: transparent; border: 2px solid #00ff00; color: #00ff00; padding: 15px 40px; font-size: 18px; cursor: pointer; font-family: 'Courier New'; text-shadow: 0 0 5px #00ff00; transition: all 0.3s; border-radius: 4px; }
        .over button:hover { background: #00ff00; color: #000; transform: scale(1.05); }
        .wave { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 56px; color: #00ffff; text-shadow: 0 0 30px #00ffff; z-index: 15; display: none; animation: w 2s; }
        @keyframes w { 0%, 100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); } }
    </style>
</head>
<body>
    <div class="wrap">
        <div class="ui">
            <div>SCORE: <span id="s">0</span></div>
            <div>HIGH: <span id="h">0</span></div>
            <div>WAVE: <span id="w">1</span></div>
        </div>
        <canvas id="c"></canvas>
        <div class="hp-bar"><div class="hp-fill" id="hp" style="width:100%"></div></div>
        <div class="wave" id="wt">WAVE 1</div>
        <div class="over" id="over">
            <h2>GAME OVER</h2>
            <p id="fs">FINAL SCORE: 0</p>
            <button onclick="restart()">PLAY AGAIN</button>
        </div>
    </div>
    <script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const W=900, H=700;
c.width=W; c.height=H;

function resize() {
    const scale = Math.min(window.innerWidth/W, window.innerHeight/H)*0.55;
    c.style.width=(W*scale)+'px';
    c.style.height=(H*scale)+'px';
}
resize();
window.addEventListener('resize',resize);

// Types with EXACT specs - INCREASED ATTACK RATES
const TYPES = {
    SCOUT: {hp:1,col:'#39FF14',sz:38,pts:10,dmg:1,fire:0.002,wt:100},
    ZAP: {hp:1,col:'#00ffff',sz:32,pts:25,dmg:1,fire:0.0006,wt:35},
    TANK: {hp:5,col:'#ff0000',sz:52,pts:50,dmg:3,fire:0.0004,wt:15},
    SPLITTER: {hp:2,col:'#ffff00',sz:40,pts:40,dmg:1,fire:0.0012,wt:25,split:true}, // More often
    BOMBER: {hp:3,col:'#ff00ff',sz:46,pts:60,dmg:5,fire:0.0008,wt:10}, // More often
    ELITE: {hp:4,col:'#ff8800',sz:44,pts:100,dmg:2,fire:0.0012,wt:5}, // Much more often!
    BOSS: {hp:18,col:'#ffffff',sz:80,pts:500,dmg:5,fire:0.002,wt:1} // Much more often!
};

let player,bullets,eBullets,enemies,particles,stars,shields,powerups;
let score,high,wave,hp,gameOver,keys,moveDir,moveTimer,dropDist;
let shakeX,shakeY,shakeInt,rapidFire,rapidTimer,projectileBoost,boostTimer,spacePressed;

let audioCtx;
function initAudio(){audioCtx=new(window.AudioContext||window.webkitAudioContext)();}
function tone(f,d,t='square',v=0.1){
    if(!audioCtx)initAudio();
    const o=audioCtx.createOscillator(),g=audioCtx.createGain();
    o.connect(g);g.connect(audioCtx.destination);
    o.frequency.value=f;o.type=t;
    g.gain.setValueAtTime(v,audioCtx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+d);
    o.start();o.stop(audioCtx.currentTime+d);
}

function init() {
    player={x:450,y:650,w:45,h:28,spd:450,dx:0,hp:10,maxHp:10};
    bullets=[]; eBullets=[]; enemies=[]; particles=[]; powerups=[];
    stars=[]; score=0; high=parseInt(localStorage.getItem('inv-high'))||0;
    wave=1; hp=10; gameOver=false; keys={}; moveDir=1; moveTimer=0; dropDist=25;
    shakeX=shakeY=shakeInt=0; rapidFire=false; rapidTimer=0; projectileBoost=false; boostTimer=0; spacePressed=false;
    
    for(let i=0;i<120;i++) stars.push({x:Math.random()*W,y:Math.random()*H,sz:1+Math.random()*2,spd:0.3+Math.random(),br:0.3+Math.random()*0.7});
    
    // Shields - PROPERLY CENTERED
    shields=[];
    const sy=580;
    const shieldW=90;
    // Center 3 shields with proper spacing
    const shield1X=(W/2)-shieldW/2-180; // Left shield
    const shield2X=(W/2)-shieldW/2;      // Center shield
    const shield3X=(W/2)-shieldW/2+180;  // Right shield
    
    for(let i=0;i<3;i++) {
        const sx=[shield1X,shield2X,shield3X][i];
        const shield={x:sx,y:sy,w:shieldW,h:55,pix:[]};
        for(let y=0;y<shield.h;y++) {
            shield.pix[y]=[];
            for(let x=0;x<shield.w;x++) {
                const dx=(x-shield.w/2)/(shield.w/2);
                const dy=y/shield.h;
                const curve = dy<0.5 ? Math.sqrt(1-dx*dx) : 1;
                shield.pix[y][x] = (dy<0.5 ? (1-dy/0.5)<curve : dy<0.7) ? 1:0;
            }
        }
        shields.push(shield);
    }
    
    document.getElementById('h').textContent=high;
    spawnWave();
}

function spawnWave() {
    enemies=[];
    const isBoss = wave%5===0;
    
    // Weight system
    const weights={};
    Object.keys(TYPES).forEach(k=>{
        const t=TYPES[k];
        let w=t.wt;
        if(wave<=2) {
            if(k==='SCOUT')w=200;
            if(k==='ZAP')w=40;
            if(k==='TANK')w=10;
            if(k==='SPLITTER')w=20;
            if(k==='BOMBER'||k==='ELITE'||k==='BOSS')w=0;
        } else if(wave<=4) {
            if(k==='SCOUT')w=150;
            if(k==='ZAP')w=60;
            if(k==='TANK')w=25;
            if(k==='SPLITTER')w=35;
            if(k==='BOMBER')w=15;
            if(k==='ELITE')w=5;
            if(k==='BOSS')w=0;
        } else if(wave<=7) {
            if(k==='SCOUT')w=100;
            if(k==='ZAP')w=50;
            if(k==='TANK')w=35;
            if(k==='SPLITTER')w=40;
            if(k==='BOMBER')w=25;
            if(k==='ELITE')w=15;
            if(k==='BOSS')w=3;
        } else {
            w=t.wt+(wave-8)*(k==='BOSS'?1.5:k==='ELITE'?2:0); // Reduced multipliers
            if(k==='SCOUT')w=Math.max(40,100-(wave-8)*3); // Reduced from *5 to *3
        }
        weights[k]=w;
    });
    
    if(isBoss) {
        enemies.push(createEnemy('BOSS',W/2-40,50));
        for(let i=0;i<6;i++) enemies.push(createEnemy('ELITE',100+i*130,100));
    } else {
        const rows=Math.min(4+Math.floor(wave/3),6);
        const cols=9;
        const groupW=cols*70;
        const startX=(W-groupW)/2+35;
        for(let r=0;r<rows;r++) {
            for(let c=0;c<cols;c++) {
                const type=pickWeighted(weights);
                enemies.push(createEnemy(type,startX+c*70,40+r*55));
            }
        }
    }
    
    document.getElementById('w').textContent=wave;
    showWave();
}

function pickWeighted(weights) {
    const arr=[];
    Object.keys(weights).forEach(k=>{
        for(let i=0;i<weights[k];i++)arr.push(k);
    });
    return arr[Math.floor(Math.random()*arr.length)];
}

function createEnemy(type,x,y) {
    const t=TYPES[type];
    return {type,x,y,w:t.sz,h:t.sz,hp:t.hp,maxHp:t.hp,col:t.col,pts:t.pts,dmg:t.dmg,fire:t.fire*(1+wave*0.03),split:t.split||false}; // Reduced from 0.05 to 0.03
}

function showWave() {
    const wt=document.getElementById('wt');
    wt.textContent=wave%5===0?'‚ö† BOSS ‚ö†':`WAVE ${wave}`;
    wt.style.display='block';
    wt.style.animation='none';
    setTimeout(()=>wt.style.animation='w 2s',10);
    setTimeout(()=>wt.style.display='none',2000);
}

function shake(i){shakeInt=i;}

function parts(x,y,col,n=15) {
    for(let i=0;i<n;i++) {
        const ang=Math.PI*2*i/n+(Math.random()-0.5)*0.5;
        const spd=100+Math.random()*200;
        particles.push({x,y,vx:Math.cos(ang)*spd,vy:Math.sin(ang)*spd,life:1,sz:2+Math.random()*3,col});
    }
}

function update(dt) {
    if(gameOver)return;
    
    stars.forEach(s=>{s.y+=s.spd*dt;if(s.y>H){s.y=0;s.x=Math.random()*W;}});
    
    if(rapidFire){rapidTimer-=dt;if(rapidTimer<=0){rapidFire=false;tone(150,0.2);}}
    if(projectileBoost){boostTimer-=dt;if(boostTimer<=0){projectileBoost=false;tone(200,0.2);}}
    
    // Player
    if(keys['ArrowLeft']||keys['a'])player.x=Math.max(0,player.x-player.spd*dt);
    if(keys['ArrowRight']||keys['d'])player.x=Math.min(W-player.w,player.x+player.spd*dt);
    
    // Bullets - FIXED: prevent continuous collision with same enemy
    bullets=bullets.filter(b=>{
        b.y-=700*dt;
        if(b.y<0)return false;
        
        if(!b.hitEnemies) b.hitEnemies=[]; // Track which enemies already hit
        
        for(let i=enemies.length-1;i>=0;i--) {
            const e=enemies[i];
            // Skip if already hit this enemy
            if(b.hitEnemies.includes(i)) continue;
            
            if(b.x>e.x-8&&b.x<e.x+e.w+8&&b.y>e.y-8&&b.y<e.y+e.h+8) {
                b.hitEnemies.push(i); // Mark as hit
                e.hp-=(b.boosted?2:1);
                parts(b.x,b.y,e.col,12);
                tone(800,0.06);
                
                if(e.hp<=0) {
                    score+=e.pts;
                    document.getElementById('s').textContent=score;
                    if(score>high){high=score;localStorage.setItem('inv-high',high);document.getElementById('h').textContent=high;}
                    tone(280,0.2,'sawtooth');
                    parts(e.x+e.w/2,e.y+e.h/2,e.col,30);
                    shake(e.type==='BOSS'?30:8);
                    if(e.type==='BOSS')tone(100,0.5,'sawtooth',0.3);
                    
                    if(e.split&&Math.random()<0.5) {
                        enemies.push(createEnemy('SCOUT',e.x-25,e.y));
                        enemies.push(createEnemy('SCOUT',e.x+25,e.y));
                    }
                    
                    if(Math.random()<0.03) {
                        const typeWeights={rapid:20,shield:25,nuke:2,heal:20};
                        const typeArr=[];
                        Object.keys(typeWeights).forEach(t=>{
                            for(let i=0;i<typeWeights[t];i++)typeArr.push(t);
                        });
                        const type=typeArr[Math.floor(Math.random()*typeArr.length)];
                        powerups.push({type:type,x:e.x,y:e.y,spd:180});
                    }
                    
                    enemies.splice(i,1);
                }
                
                // Boosted bullets can hit 2 enemies total
                if(b.boosted && b.hitEnemies.length>=2) return false;
                // Normal bullets stop after 1 hit
                if(!b.boosted) return false;
            }
        }
        return true;
    });
    
    // Enemy bullets
    eBullets=eBullets.filter(b=>{
        // Charging projectiles stay attached to alien
        if(b.type==='eliteCharging') {
            // Remove if marked for removal OR parent died OR charge expired
            if(b.shouldRemove) return false;
            if(!b.parentAlien || b.parentAlien.hp<=0) return false;
            
            b.chargeProgress+=dt;
            if(b.chargeProgress>=b.maxCharge) return false; // Expired
            
            const alienCX=b.parentAlien.x+b.parentAlien.w/2;
            const alienCY=b.parentAlien.y+b.parentAlien.h;
            b.x=alienCX+b.attachX;
            b.y=alienCY;
            
            // Charge particles
            if(Math.random()<0.25) {
                const ang=Math.random()*Math.PI*2;
                particles.push({
                    x:b.x+Math.random()*8-4,y:b.y+Math.random()*8-4,
                    vx:Math.cos(ang)*40,vy:Math.sin(ang)*40-60,
                    life:0.5,sz:2,col:'#ff8800'
                });
            }
            
            // LOW frequency charge sound
            const chargePct=b.chargeProgress/b.maxCharge;
            if(Math.random()<0.08) {
                tone(200+chargePct*150,0.08,'sine',0.04);
            }
            
            return true;
        }
        
        // Normal bullet movement
        if(b.vx!==undefined&&b.vy!==undefined) {
            b.x+=b.vx*dt;
            b.y+=b.vy*dt;
        } else {
            b.y+=(b.spd||350)*dt;
        }
        
        // ELITE homing with ACTIVATION RADIUS - MAINTAIN SPEED
        if(b.homing&&player&&b.type==='elite') {
            const dx=(player.x+player.w/2)-b.x;
            const dy=(player.y+player.h/2)-b.y;
            const dist=Math.sqrt(dx*dx+dy*dy);
            const activationRadius=b.homingRadius||250;
            
            // Calculate current speed
            const currentSpeed=Math.sqrt(b.vx*b.vx+b.vy*b.vy);
            
            // Only home if within activation radius!
            if(dist<activationRadius) {
                const targetAngle=Math.atan2(dx,dy);
                const currentAngle=b.angle||0;
                const angleDiff=targetAngle-currentAngle;
                const maxTurn=0.4;
                
                // Normalize angle
                let normalizedDiff=angleDiff;
                while(normalizedDiff>Math.PI)normalizedDiff-=Math.PI*2;
                while(normalizedDiff<-Math.PI)normalizedDiff+=Math.PI*2;
                
                // Turn towards player
                const turnAmount=Math.max(-maxTurn*dt*4,Math.min(maxTurn*dt*4,normalizedDiff));
                b.angle=currentAngle+turnAmount;
                
                // Apply velocity at SAME SPEED (600!)
                b.vx=Math.sin(b.angle)*600;
                b.vy=Math.cos(b.angle)*600;
            }
        }
        
        if(b.y>H||b.x<-50||b.x>W+50)return false;
        
        if(b.x>player.x&&b.x<player.x+player.w&&b.y>player.y&&b.y<player.y+player.h) {
            player.hp-=b.dmg||1;
            document.getElementById('hp').style.width=(player.hp/player.maxHp*100)+'%';
            parts(b.x,b.y,'#ff0000',20);
            shake(15);
            tone(100,0.4,'triangle',0.25);
            if(player.hp<=0)endGame();
            return false;
        }
        
        for(let s of shields) {
            const sx=Math.floor(b.x-s.x);
            const sy=Math.floor(b.y-s.y);
            if(sx>=0&&sx<s.w&&sy>=0&&sy<s.h&&s.pix[sy]&&s.pix[sy][sx]) {
                const rad=b.bombRadius||4;
                for(let dy=-rad;dy<=rad;dy++) {
                    for(let dx=-rad;dx<=rad;dx++) {
                        const px=sx+dx, py=sy+dy;
                        if(px>=0&&px<s.w&&py>=0&&py<s.h&&s.pix[py]&&Math.sqrt(dx*dx+dy*dy)<=rad) s.pix[py][px]=0;
                    }
                }
                parts(b.x,b.y,'#00ff00',12);
                tone(400,0.1);
                return false;
            }
        }
        return true;
    });
    
    // Typewriter movement
    moveTimer+=dt*1000;
    const moveInt=Math.max(700,1700-wave*8); // Reduced from wave*12 to wave*8
    if(moveTimer>=moveInt) {
        moveTimer=0;
        let hitEdge=false;
        enemies.forEach(e=>{
            e.x+=65*moveDir;
            if(e.x<=15||e.x+e.w>=W-15)hitEdge=true;
        });
        if(hitEdge) {
            moveDir*=-1;
            enemies.forEach(e=>e.y+=dropDist);
            dropDist=Math.min(35,dropDist+2);
        }
    }
    
    // Individual patterns
    enemies.forEach(e=>{
        if(!e.angle)e.angle=Math.random()*Math.PI*2;
        if(!e.patternTimer)e.patternTimer=0;
        if(!e.dir)e.dir=Math.random()>0.5?1:-1;
        e.angle+=dt*3;
        e.patternTimer+=dt;
        
        if(e.type==='SCOUT') {
        } else if(e.type==='ZAP') {
            e.x+=Math.sin(e.angle*2.5)*200*dt;
        } else if(e.type==='TANK') {
            e.x+=Math.sin(e.angle)*40*dt;
        } else if(e.type==='SPLITTER') {
            e.x+=Math.sin(e.angle*1.5)*80*dt;
        } else if(e.type==='BOMBER') {
            if(e.patternTimer>1.5) {
                e.patternTimer=0;
                e.dir=Math.random()<0.5?1:-1;
                if(Math.random()<0.3)e.dir=0;
            }
            e.x+=e.dir*100*dt;
            if(e.dir===0)e.y-=50*dt;
            
            // Keep on screen!
            if(e.x<20) {e.x=20; e.dir=1;}
            if(e.x+e.w>W-20) {e.x=W-20-e.w; e.dir=-1;}
            
            // Stay at the back! Move up if too far forward
            if(e.y>300) e.y-=80*dt;
            
            const nearby=enemies.find(a=>a!==e&&Math.abs(a.x-e.x)<100&&a.y<e.y&&a.y>e.y-80);
            if(nearby) {
                const dx=(nearby.x+nearby.w/2)-(e.x+e.w/2);
                e.x+=Math.sign(dx)*80*dt;
            }
        } else if(e.type==='ELITE') {
            // CHAOTIC erratic movement - but STAY AT BACK
            e.x+=Math.cos(e.angle*3)*220*dt;
            e.y+=Math.sin(e.angle*2.5)*90*dt;
            // Random direction switches
            if(Math.random()<dt*2) e.angle+=Math.random()*Math.PI*0.5;
            
            // KEEP IN BOUNDS!
            if(e.x<30) {e.x=30; e.angle+=Math.PI*0.5;}
            if(e.x+e.w>W-30) {e.x=W-30-e.w; e.angle-=Math.PI*0.5;}
            
            // Stay at the back! Don't go below y=350
            if(e.y>350) e.y=350;
        } else if(e.type==='BOSS') {
            e.y=Math.max(80,Math.min(200,e.y+Math.sin(e.angle*0.3)*40*dt));
        }
        
        if(e.y+e.h>=H-100)endGame();
    });
    
    // Aliens shoot
    enemies.forEach(e=>{
        if(Math.random()<e.fire*dt*60) {
            const cx=e.x+e.w/2, cy=e.y+e.h;
            const px=player.x+player.w/2;
            
            if(e.type==='SCOUT') {
                eBullets.push({x:cx,y:cy,dmg:2,spd:350,type:'normal'});
            } else if(e.type==='ZAP') {
                // 3 projectiles each with RANDOM angle -7¬∞ to +7¬∞
                for(let i=0;i<3;i++) {
                    const angleRad=(Math.random()*14-7)*Math.PI/180; // Random -7¬∞ to +7¬∞
                    setTimeout(()=>{
                        if(!gameOver)eBullets.push({
                            x:cx,y:cy,dmg:1,spd:500,type:'zap',size:3,
                            vx:Math.sin(angleRad)*500,
                            vy:Math.cos(angleRad)*500
                        });
                    },i*100);
                }
            } else if(e.type==='TANK') {
                eBullets.push({x:cx,y:cy,dmg:3,spd:220,bombRadius:25,type:'tank',size:8}); // Increased radius
            } else if(e.type==='SPLITTER') {
                // Shoot 2 projectiles!
                for(let j=0;j<2;j++) {
                    const angleRad=(Math.random()*30-15)*Math.PI/180;
                    setTimeout(()=>{
                        if(!gameOver) eBullets.push({
                            x:cx,y:cy,dmg:2,spd:480,type:'fast',size:5,
                            vx:Math.sin(angleRad)*480,
                            vy:Math.cos(angleRad)*480
                        });
                    },j*80);
                }
            } else if(e.type==='BOMBER') {
                // FAST DEADLY bombs that DECIMATE shields!
                eBullets.push({x:cx,y:cy,dmg:5,spd:450,bombRadius:35,type:'bomb',size:12,shake:18});
                // Also shoot waves of small projectiles
                if(Math.random()<0.5) {
                    const count=5+Math.floor(Math.random()*6); // 5-10 projectiles
                    for(let j=0;j<count;j++) {
                        const spread=(j-count/2)*0.15;
                        setTimeout(()=>{
                            if(!gameOver) eBullets.push({
                                x:cx,y:cy,dmg:1,spd:520,type:'bomberWave',size:4,
                                vx:Math.sin(spread)*520,
                                vy:Math.cos(spread)*520
                            });
                        },j*50);
                    }
                }
            } else if(e.type==='ELITE') {
                // CHARGED projectiles - stay attached during charge!
                const leftX=cx-e.w*0.5;
                const rightX=cx+e.w*0.5;
                
                const chargeTime=0.6;
                const charging1={
                    x:leftX,y:cy,attached:true,attachX:-e.w*0.5,
                    chargeProgress:0,maxCharge:chargeTime,
                    parentAlien:e,type:'eliteCharging',size:7,
                    startTime:performance.now()
                };
                const charging2={
                    x:rightX,y:cy,attached:true,attachX:e.w*0.5,
                    chargeProgress:0,maxCharge:chargeTime,
                    parentAlien:e,type:'eliteCharging',size:7,
                    startTime:performance.now()
                };
                
                eBullets.push(charging1);
                eBullets.push(charging2);
                
                // Launch after charge completes
                setTimeout(()=>{
                    if(!gameOver && e.alive!==false) {
                        // PROPERLY remove charging projectiles by marking them
                        charging1.shouldRemove=true;
                        charging2.shouldRemove=true;
                        
                        const currentCX=e.x+e.w/2, currentCY=e.y+e.h;
                        const leftAngle=-0.5;
                        const rightAngle=0.5;
                        
                        // Explosion particles
                        for(let j=0;j<15;j++) {
                            const ang=Math.random()*Math.PI*2;
                            particles.push({
                                x:currentCX-e.w*0.5,y:currentCY,
                                vx:Math.cos(ang)*150,vy:Math.sin(ang)*150,
                                life:0.6,sz:3,col:'#ff8800'
                            });
                            particles.push({
                                x:currentCX+e.w*0.5,y:currentCY,
                                vx:Math.cos(ang)*150,vy:Math.sin(ang)*150,
                                life:0.6,sz:3,col:'#ff8800'
                            });
                        }
                        
                        // Launch projectiles
                        eBullets.push({
                            x:currentCX-e.w*0.5,y:currentCY,dmg:2,
                            vx:Math.sin(leftAngle)*600,
                            vy:Math.cos(leftAngle)*600,
                            homing:true,homingRadius:250, // Activation radius!
                            maxDeviation:0.4,homingStr:230,
                            angle:leftAngle,
                            type:'elite',size:8,glow:true
                        });
                        
                        eBullets.push({
                            x:currentCX+e.w*0.5,y:currentCY,dmg:2,
                            vx:Math.sin(rightAngle)*600,
                            vy:Math.cos(rightAngle)*600,
                            homing:true,homingRadius:250,
                            maxDeviation:0.4,homingStr:230,
                            angle:rightAngle,
                            type:'elite',size:8,glow:true
                        });
                        
                        tone(1400,0.15,'sine',0.12);
                        shake(8);
                    }
                },chargeTime*1000);
            } else if(e.type==='BOSS') {
                const pattern=Math.floor(Math.random()*4);
                
                if(pattern===0) { // üåü SPAWN ASSAULT - Spawn 3 random aliens!
                    if(enemies.length<40) {
                        // Spawn 3 random alien types (not BOSS)
                        const spawnTypes=['SCOUT','ZAP','TANK','SPLITTER','BOMBER','ELITE'];
                        for(let i=0;i<3;i++) {
                            const randomType=spawnTypes[Math.floor(Math.random()*spawnTypes.length)];
                            const side=(i-1)*e.w*0.35;
                            const spawnedAlien=createEnemy(randomType,e.x+side+e.w/2,e.y+e.h);
                            enemies.push(spawnedAlien);
                            // Spawn particles
                            for(let j=0;j<20;j++) {
                                const ang=Math.random()*Math.PI*2;
                                particles.push({
                                    x:spawnedAlien.x+spawnedAlien.w/2,
                                    y:spawnedAlien.y+spawnedAlien.h/2,
                                    vx:Math.cos(ang)*180,vy:Math.sin(ang)*180,
                                    life:0.8,sz:3,col:spawnedAlien.col
                                });
                            }
                        }
                        tone(800,0.2,'square');
                        tone(600,0.25,'square');
                        shake(12);
                    }
                    
                } else if(pattern===1) { // üí£ CARPET BOMBING - Wave of bombs!
                    for(let i=-3;i<=3;i++) {
                        setTimeout(()=>{
                            if(!gameOver) {
                                eBullets.push({
                                    x:cx+i*25,y:cy,dmg:5,spd:180,
                                    bombRadius:40,type:'bossBomb',size:14,shake:25
                                });
                                tone(300-i*20,0.1,'sawtooth',0.1);
                            }
                        },Math.abs(i)*80); // Cascade timing!
                    }
                    shake(15);
                    
                } else if(pattern===2) { // üå™Ô∏è SPIRAL BARRAGE - Rotating spread!
                    for(let wave=0;wave<3;wave++) {
                        setTimeout(()=>{
                            if(!gameOver) {
                                const rotation=wave*0.3; // Rotate each wave
                                for(let i=-5;i<=5;i++) {
                                    const angle=i*0.22+rotation;
                                    eBullets.push({
                                        x:cx,y:cy,dmg:1,spd:580,type:'bossSpread',
                                        vx:Math.sin(angle)*580,
                                        vy:Math.cos(angle)*580,
                                        size:5
                                    });
                                }
                                tone(1200+wave*200,0.1,'sine',0.08);
                            }
                        },wave*200);
                    }
                    shake(10);
                    
                } else { // üéØ SNIPER STRIKE - Aimed burst at player!
                    const px=player.x+player.w/2;
                    const angleToPlayer=Math.atan2(px-cx,150);
                    
                    // Fire 5 projectiles in quick succession
                    for(let burst=0;burst<5;burst++) {
                        setTimeout(()=>{
                            if(!gameOver) {
                                const spreadAngle=angleToPlayer+(burst-2)*0.08;
                                eBullets.push({
                                    x:cx,y:cy,dmg:3,spd:550,
                                    vx:Math.sin(spreadAngle)*550,
                                    vy:Math.cos(spreadAngle)*550,
                                    bombRadius:7,type:'bossDirect',size:9
                                });
                                // Red warning particles
                                for(let j=0;j<8;j++) {
                                    const ang=Math.random()*Math.PI*2;
                                    particles.push({
                                        x:cx,y:cy,
                                        vx:Math.cos(ang)*100,vy:Math.sin(ang)*100,
                                        life:0.4,sz:2,col:'#ff0000'
                                    });
                                }
                                tone(1400-burst*50,0.08,'square',0.1);
                            }
                        },burst*120); // Rapid fire!
                    }
                    shake(8);
                }
            }
        }
    });
    
    // Powerups
    powerups=powerups.filter(p=>{
        p.y+=p.spd*dt;
        if(p.y>H)return false;
        if(p.x>player.x&&p.x<player.x+player.w&&p.y>player.y&&p.y<player.y+player.h) {
            if(p.type==='shield') {
                shields.forEach(s=>{
                    for(let y=0;y<s.h;y++)for(let x=0;x<s.w;x++){
                        const dx=(x-s.w/2)/(s.w/2),dy=y/s.h;
                        const curve=dy<0.5?Math.sqrt(1-dx*dx):1;
                        if(dy<0.5?(1-dy/0.5)<curve:dy<0.85)s.pix[y][x]=1;
                    }
                });
            } else if(p.type==='nuke') {
                enemies.forEach(e=>{score+=e.pts;parts(e.x+e.w/2,e.y+e.h/2,e.col,20);});
                document.getElementById('s').textContent=score;
                enemies=[];
                shake(35);
                tone(140,0.7,'sawtooth');
            } else if(p.type==='heal') {
                player.hp=Math.min(player.maxHp,player.hp+1);
                document.getElementById('hp').style.width=(player.hp/player.maxHp*100)+'%';
            } else if(p.type==='rapid') {
                projectileBoost=true;boostTimer=6;
            }
            const col=p.type==='heal'?'#ff0000':p.type==='rapid'?'#ffff00':p.type==='shield'?'#00ff00':'#ff00ff';
            parts(p.x,p.y,col,15);
            tone(950,0.25,'sine');
            return false;
        }
        return true;
    });
    
    particles=particles.filter(p=>{p.x+=p.vx*dt;p.y+=p.vy*dt;p.vy+=300*dt;p.life-=dt*2.5;return p.life>0;});
    
    if(shakeInt>0){shakeX=(Math.random()-0.5)*shakeInt;shakeY=(Math.random()-0.5)*shakeInt;shakeInt*=0.85;if(shakeInt<0.1){shakeInt=0;shakeX=shakeY=0;}}
    
    if(enemies.length===0) {wave++;tone(523,0.3,'sine');tone(659,0.3,'sine');spawnWave();}
}

function endGame() {
    gameOver=true;
    document.getElementById('fs').textContent=`FINAL SCORE: ${score}`;
    document.getElementById('over').style.display='block';
    tone(220,1,'sawtooth',0.15);
}

function restart() {
    document.getElementById('over').style.display='none';
    init();
}

function draw() {
    ctx.save();
    ctx.translate(shakeX,shakeY);
    ctx.fillStyle='#000';
    ctx.fillRect(0,0,W,H);
    
    stars.forEach(s=>{ctx.globalAlpha=s.br;ctx.fillStyle='#fff';ctx.fillRect(s.x,s.y,s.sz,s.sz);});
    ctx.globalAlpha=1;
    
    ctx.fillStyle='#00ff00';
    ctx.shadowBlur=10;
    ctx.shadowColor='#00ff00';
    shields.forEach(s=>{
        ctx.beginPath();
        for(let y=0;y<s.h;y++)for(let x=0;x<s.w;x++)if(s.pix[y][x])ctx.rect(s.x+x,s.y+y,1,1);
        ctx.fill();
    });
    ctx.shadowBlur=0;
    
    const px=player.x+player.w/2, py=player.y;
    ctx.fillStyle='#00ff00';
    ctx.shadowBlur=25;
    ctx.shadowColor='#00ff00';
    ctx.beginPath();
    ctx.moveTo(px,py);
    ctx.lineTo(px-14,py+12);
    ctx.lineTo(px-10,py+18);
    ctx.lineTo(px-6,py+28);
    ctx.lineTo(px+6,py+28);
    ctx.lineTo(px+10,py+18);
    ctx.lineTo(px+14,py+12);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle='#00ffff';
    ctx.beginPath();
    ctx.moveTo(px-14,py+12);
    ctx.lineTo(px-20,py+14);
    ctx.lineTo(px-16,py+18);
    ctx.lineTo(px-10,py+18);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(px+14,py+12);
    ctx.lineTo(px+20,py+14);
    ctx.lineTo(px+16,py+18);
    ctx.lineTo(px+10,py+18);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle='#ffffff';
    ctx.beginPath();
    ctx.arc(px,py+8,3,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle='#00ffff';
    ctx.shadowBlur=20;
    ctx.shadowColor='#00ffff';
    for(let i=-1;i<=1;i+=2) {
        ctx.beginPath();
        ctx.ellipse(px+i*5,py+28,3,5,0,0,Math.PI*2);
        ctx.fill();
    }
    ctx.shadowBlur=0;
    
    bullets.forEach(b=>{
        ctx.fillStyle=b.boosted?'#ff00ff':(rapidFire?'#ffff00':'#00ffff');
        ctx.shadowBlur=10;
        ctx.shadowColor=ctx.fillStyle;
        ctx.fillRect(b.x-2,b.y,4,12);
    });
    ctx.shadowBlur=0;
    
    eBullets.forEach(b=>{
        const sz=b.size||4;
        
        if(b.type==='eliteCharging') {
            // CHARGING visual - pulses and grows!
            const chargePct=Math.min(1,b.chargeProgress/b.maxCharge);
            const pulse=Math.sin(performance.now()/30)*0.3+0.7;
            const chargeSize=sz*(0.5+chargePct*0.8); // Grows as charges
            
            ctx.fillStyle='#ff8800';
            ctx.shadowBlur=(20+chargePct*30)*pulse; // Brighter as charges
            ctx.shadowColor='#ff8800';
            
            // Outer charging ring
            ctx.globalAlpha=0.4+chargePct*0.4;
            ctx.beginPath();
            ctx.arc(b.x,b.y,chargeSize*3*pulse,0,Math.PI*2);
            ctx.fill();
            ctx.globalAlpha=1;
            
            // Main orb
            ctx.beginPath();
            ctx.arc(b.x,b.y,chargeSize,0,Math.PI*2);
            ctx.fill();
            
            // Bright core (grows)
            ctx.fillStyle='#ffffff';
            ctx.beginPath();
            ctx.arc(b.x,b.y,chargeSize*0.6*chargePct,0,Math.PI*2);
            ctx.fill();
            
            // Energy ring
            ctx.strokeStyle='#ffff00';
            ctx.lineWidth=2+chargePct*2;
            ctx.globalAlpha=pulse*chargePct;
            ctx.beginPath();
            ctx.arc(b.x,b.y,chargeSize*2,0,Math.PI*2);
            ctx.stroke();
            ctx.globalAlpha=1;
        } else if(b.type==='zap') {
            ctx.fillStyle='#00ffff';
            ctx.shadowBlur=15;
            ctx.shadowColor='#00ffff';
            ctx.fillRect(b.x-sz/2,b.y-2,sz,8);
            ctx.globalAlpha=0.5;
            ctx.fillRect(b.x-sz,b.y-4,sz*2,12);
            ctx.globalAlpha=1;
        } else if(b.type==='tank'||b.type==='bomb'||b.type==='bossBomb') {
            const col=b.type==='bossBomb'?'#ffffff':b.type==='bomb'?'#ff00ff':'#ff6600';
            ctx.fillStyle=col;
            ctx.shadowBlur=25;
            ctx.shadowColor=col;
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            // Larger glow for big bombs
            ctx.globalAlpha=0.4;
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz*2.5,0,Math.PI*2);
            ctx.fill();
            ctx.globalAlpha=1;
        } else if(b.type==='elite') {
            // GLOWING charged projectiles!
            const pulse=Math.sin(performance.now()/50)*0.3+0.7;
            ctx.fillStyle='#ff8800';
            ctx.shadowBlur=30*pulse;
            ctx.shadowColor='#ff8800';
            // Glowing trail
            ctx.globalAlpha=0.7;
            for(let i=1;i<=4;i++) {
                ctx.beginPath();
                ctx.arc(b.x,b.y+i*6,sz-i*0.5,0,Math.PI*2);
                ctx.fill();
            }
            ctx.globalAlpha=1;
            // Main projectile
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            // Bright core
            ctx.fillStyle='#ffffff';
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz*0.5,0,Math.PI*2);
            ctx.fill();
            // Outer glow ring
            ctx.strokeStyle='#ff8800';
            ctx.lineWidth=2;
            ctx.globalAlpha=pulse;
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz*1.5,0,Math.PI*2);
            ctx.stroke();
            ctx.globalAlpha=1;
        } else if(b.type==='bomberWave') {
            // Small fast magenta projectiles
            ctx.fillStyle='#ff00ff';
            ctx.shadowBlur=12;
            ctx.shadowColor='#ff00ff';
            ctx.fillRect(b.x-sz/2,b.y-sz/2,sz,sz);
            ctx.globalAlpha=0.5;
            ctx.fillRect(b.x-sz,b.y-sz,sz*2,sz*2);
            ctx.globalAlpha=1;
        } else if(b.type==='bossSpread') {
            ctx.fillStyle='#ffffff';
            ctx.shadowBlur=12;
            ctx.shadowColor='#ffffff';
            ctx.fillRect(b.x-sz/2,b.y-sz/2,sz,sz*2);
            ctx.globalAlpha=0.5;
            ctx.fillRect(b.x-sz,b.y-sz,sz*2,sz*3);
            ctx.globalAlpha=1;
        } else if(b.type==='bossDirect') {
            ctx.fillStyle='#ff0000';
            ctx.shadowBlur=20;
            ctx.shadowColor='#ff0000';
            ctx.beginPath();
            ctx.arc(b.x,b.y,sz,0,Math.PI*2);
            ctx.fill();
            ctx.fillStyle='#ffffff';
            ctx.fillRect(b.x-1,b.y-sz,2,sz*2);
        } else if(b.type==='fast') {
            ctx.fillStyle='#ffff00';
            ctx.shadowBlur=15;
            ctx.shadowColor='#ffff00';
            ctx.fillRect(b.x-sz/2,b.y,sz,12);
        } else {
            ctx.fillStyle='#ff0000';
            ctx.shadowBlur=12;
            ctx.shadowColor='#ff0000';
            ctx.fillRect(b.x-2,b.y,4,10);
        }
        ctx.shadowBlur=0;
        ctx.globalAlpha=1;
    });
    
    // CLASSIC SPACE INVADERS ALIENS - EXACTLY like the reference
    enemies.forEach(e=>{
        const cx=e.x+e.w/2, cy=e.y+e.h/2, s=e.w;
        const px=s/11; // Pixel size
        
        ctx.fillStyle=e.col;
        ctx.shadowBlur=15;
        ctx.shadowColor=e.col;
        
        if(e.type==='SCOUT') {
            // Top row - squid (3 bumps on top)
            ctx.fillRect(cx-px*3,cy-px*5,px,px);
            ctx.fillRect(cx-px,cy-px*5,px,px);
            ctx.fillRect(cx+px*2,cy-px*5,px,px);
            // Head
            ctx.fillRect(cx-px*4,cy-px*4,px*8,px*2);
            ctx.fillRect(cx-px*5,cy-px*2,px*10,px*2);
            // Body
            ctx.fillRect(cx-px*4,cy,px*8,px*2);
            // Side fins
            ctx.fillRect(cx-px*6,cy-px*1,px,px*3);
            ctx.fillRect(cx+px*5,cy-px*1,px,px*3);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*2.5,cy-px*2,px,px);
            ctx.fillRect(cx+px*1.5,cy-px*2,px,px);
        } else if(e.type==='ZAP') {
            // Middle row - crab
            ctx.fillStyle=e.col;
            // Top bumps
            ctx.fillRect(cx-px*3,cy-px*5,px,px);
            ctx.fillRect(cx+px*2,cy-px*5,px,px);
            // Head
            ctx.fillRect(cx-px*4,cy-px*4,px*8,px*2);
            ctx.fillRect(cx-px*4.5,cy-px*2,px*9,px*2);
            // Body
            ctx.fillRect(cx-px*3.5,cy,px*7,px*2);
            // Claws
            ctx.fillRect(cx-px*5.5,cy-px*2,px,px*4);
            ctx.fillRect(cx+px*4.5,cy-px*2,px,px*4);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*2,cy-px*2,px,px);
            ctx.fillRect(cx+px,cy-px*2,px,px);
        } else if(e.type==='SPLITTER') {
            // Bottom row - octopus
            ctx.fillStyle=e.col;
            // Head bumps
            ctx.fillRect(cx-px*3.5,cy-px*4,px,px);
            ctx.fillRect(cx-px*1,cy-px*4,px,px);
            ctx.fillRect(cx+px*2.5,cy-px*4,px,px);
            // Head
            ctx.fillRect(cx-px*4,cy-px*3,px*8,px*2);
            ctx.fillRect(cx-px*5,cy-px*1,px*10,px*2);
            // Body
            ctx.fillRect(cx-px*4,cy+px,px*8,px*2);
            // Bottom tentacles
            ctx.fillRect(cx-px*3.5,cy+px*3,px,px*2);
            ctx.fillRect(cx+px*2.5,cy+px*3,px,px*2);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*2.5,cy-px,px,px);
            ctx.fillRect(cx+px*1.5,cy-px,px,px);
        } else if(e.type==='TANK') {
            // Tank version - bigger, armored
            ctx.fillStyle=e.col;
            // Turret
            ctx.fillRect(cx-px*2,cy-px*5,px*4,px);
            // Top armor
            ctx.fillRect(cx-px*4,cy-px*4,px*8,px*2);
            // Main body
            ctx.fillRect(cx-px*5,cy-px*2,px*10,px*3);
            // Side cannons
            ctx.fillRect(cx-px*6,cy-px*1,px,px*2);
            ctx.fillRect(cx+px*5,cy-px*1,px,px*2);
            // Lower armor
            ctx.fillRect(cx-px*4,cy+px,px*8,px*2);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*2,cy-px*1,px,px);
            ctx.fillRect(cx+px,cy-px*1,px,px);
        } else if(e.type==='BOMBER') {
            // Bomber - UFO style
            ctx.fillStyle=e.col;
            // Dome top
            ctx.fillRect(cx-px*2,cy-px*5,px*4,px);
            ctx.fillRect(cx-px*3,cy-px*4,px*6,px);
            // Main saucer
            ctx.fillRect(cx-px*5,cy-px*3,px*10,px*2);
            ctx.fillRect(cx-px*6,cy-px*1,px*12,px*2);
            // Bottom weapons
            ctx.fillRect(cx-px*4,cy+px,px*2,px*2);
            ctx.fillRect(cx-px*1,cy+px,px*2,px*2);
            ctx.fillRect(cx+px*2,cy+px,px*2,px*2);
            // Windows
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*2,cy-px*2,px,px);
            ctx.fillRect(cx+px,cy-px*2,px,px);
        } else if(e.type==='ELITE') {
            // Elite fighter
            ctx.fillStyle=e.col;
            // Cockpit spike
            ctx.fillRect(cx-px*0.5,cy-px*5,px,px);
            // Head
            ctx.fillRect(cx-px*3,cy-px*4,px*6,px);
            ctx.fillRect(cx-px*4,cy-px*3,px*8,px*2);
            // Main body
            ctx.fillRect(cx-px*3.5,cy-px*1,px*7,px*3);
            // Wings
            ctx.fillRect(cx-px*5.5,cy-px*0.5,px,px*3);
            ctx.fillRect(cx+px*4.5,cy-px*0.5,px,px*3);
            // Engine ports
            ctx.fillRect(cx-px*2.5,cy+px*2,px,px);
            ctx.fillRect(cx+px*1.5,cy+px*2,px,px);
            // Eyes
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px*1.5,cy-px*1,px,px);
            ctx.fillRect(cx+px*0.5,cy-px*1,px,px);
        } else if(e.type==='BOSS') {
            // Boss mothership
            ctx.fillStyle=e.col;
            // Bridge tower
            ctx.fillRect(cx-px*2,cy-px*6,px*4,px*2);
            // Main deck
            ctx.fillRect(cx-px*6,cy-px*4,px*12,px*3);
            // Hull
            ctx.fillRect(cx-px*7,cy-px*1,px*14,px*4);
            // Side wings
            ctx.fillRect(cx-px*8,cy,px,px*3);
            ctx.fillRect(cx+px*7,cy,px,px*3);
            // Weapons
            ctx.fillRect(cx-px*5,cy+px*3,px*2,px);
            ctx.fillRect(cx-px*1,cy+px*3,px*2,px);
            ctx.fillRect(cx+px*3,cy+px*3,px*2,px);
            // Bridge windows
            ctx.fillStyle='#000';
            ctx.fillRect(cx-px,cy-px*5,px*2,px);
        }
        
        ctx.shadowBlur=0;
        
        if(e.hp<e.maxHp) {
            const bw=e.w-8;
            ctx.fillStyle='#600';
            ctx.fillRect(e.x+4,e.y-8,bw,3);
            ctx.fillStyle='#0f0';
            ctx.fillRect(e.x+4,e.y-8,bw*(e.hp/e.maxHp),3);
        }
    });
    
    powerups.forEach(p=>{
        const col=p.type==='heal'?'#ff0000':p.type==='rapid'?'#ffff00':p.type==='shield'?'#00ff00':'#ff00ff';
        ctx.fillStyle=col;
        ctx.shadowBlur=15;
        ctx.shadowColor=col;
        ctx.fillRect(p.x-12,p.y-12,24,24);
        ctx.shadowBlur=0;
    });
    
    particles.forEach(p=>{ctx.globalAlpha=p.life;ctx.fillStyle=p.col;ctx.fillRect(p.x-p.sz/2,p.y-p.sz/2,p.sz,p.sz);});
    ctx.globalAlpha=1;
    
    ctx.restore();
}

document.addEventListener('keydown',e=>{
    keys[e.key]=true;
    if(e.key===' '&&!gameOver&&!spacePressed&&bullets.length<(rapidFire?8:5)) {
        spacePressed=true;
        bullets.push({x:player.x+player.w/2,y:player.y,boosted:projectileBoost});
        // Varied pitch shooting sound! (900-1100Hz)
        tone(900+Math.random()*200,0.08,'square',0.08);
    }
});
document.addEventListener('keyup',e=>{
    keys[e.key]=false;
    if(e.key===' ')spacePressed=false;
});

let lastTime=performance.now();
function loop(t) {
    const dt=Math.min((t-lastTime)/1000,0.1);
    lastTime=t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
}

init();
loop(performance.now());
    </script>
</body>
</html>